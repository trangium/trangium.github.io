!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.puzzleGen=e():t.puzzleGen=e()}(this,(function(){return(()=>{"use strict";var t={d:(e,s)=>{for(var i in s)t.o(s,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:s[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{Algorithm:()=>Ee,Canvas:()=>pe,CanvasVisualizer:()=>CanvasVisualizer,Colors:()=>o,Masks:()=>be,PNG:()=>me,PuzzleGeometry:()=>we,Rendering:()=>ge,SVG:()=>de,Simulator:()=>ye,SvgVisualizer:()=>SvgVisualizer,Type:()=>Yt,Visualizer:()=>Visualizer,validColor:()=>se,validatePuzzleOptions:()=>ee});var s,i,r,o={};t.r(o),t.d(o,{BLACK:()=>R,BLUE:()=>v,BLUE_STICKERLESS:()=>x,DARK_BLUE:()=>E,DARK_BLUE_STICKERLESS:()=>N,GREEN:()=>g,GREEN_STICKERLESS:()=>V,GREY:()=>y,GREY_STICKERLESS:()=>I,LIGHT_GREEN:()=>k,LIGHT_GREEN_STICKERLESS:()=>z,LIGHT_YELLOW:()=>S,LIGHT_YELLOW_STICKERLESS:()=>_,MASK_COLOR:()=>F,ORANGE:()=>b,ORANGE_STICKERLESS:()=>T,PINK:()=>C,PINK_STICKERLESS:()=>U,PURPLE:()=>w,PURPLE_STICKERLESS:()=>B,RED:()=>m,RED_STICKERLESS:()=>L,WHITE:()=>p,WHITE_STICKERLESS:()=>P,YELLOW:()=>f,YELLOW_STICKERLESS:()=>M}),function(t){t[t.Clockwise=0]="Clockwise",t[t.CounterClockwise=1]="CounterClockwise",t[t.Double=2]="Double"}(s||(s={})),function(t){t.Clockwise="",t.CounterClockwise="'",t.Double="2"}(i||(i={})),function(t){t.F="F",t.U="U",t.R="R",t.L="L",t.D="D",t.B="B",t.M="M",t.E="E",t.S="S",t.X="x",t.Y="y",t.Z="z"}(r||(r={}));const a=[r.F,r.U,r.R,r.L,r.D,r.B,r.M,r.E,r.S,r.X,r.Y,r.Z],h=[r.X,r.Y,r.Z],n=/([0-9]+)?([UuFfRrDdLlBbMESxyz])(w)?([2\'])?/g;function l(t){if(!t)return[];let e,s=[];for(;e=n.exec(t);){let t=e[1],r=e[2],o=e[3],a=e[4]||i.Clockwise,n=r===r.toLowerCase()&&-1===h.indexOf(r);n&&(r=r.toUpperCase());let l={unit:u(r),turnType:d(a),slices:n?2:c(t,o)};s.push(l)}return s}function c(t,e){if(e&&!t)return 2;if(!e&&t)throw new Error("Invalid move: Cannot specify num slices if outer block move indicator 'w' is not present");if(e||t){const e=parseInt(t);if(e>1)return e;throw new Error(`Invalid outer block move (${e}) must be greater than 1`)}return 1}function u(t){if(a.indexOf(t)<0)throw new Error(`Invalid move (${t}): Possible turn faces are [U R F L D B M E S x y z]`);return t}function d(t){switch(t){case i.Clockwise:return s.Clockwise;case i.CounterClockwise:return s.CounterClockwise;case i.Double:return s.Double;default:throw new Error(`Invalid move modifier (${t})`)}}class Simulator{constructor(){this.stickers=new Map,this.faces=new Map,this.turns=new Map}addFace(t,e){if(e&&this.faces.has(e))throw`Face ${e} already exists`;e||(e=(this.faces.size+1).toString());const s=t.reduce(((t,e)=>{const s=(this.stickers.size+1).toString();return this.stickers.set(s,e),t.push(s),t}),[]);return this.faces.set(e,s),{faceId:e,stickerIds:s}}addTurn(t,e){if(e&&this.turns.has(e))throw`Turn ${e} already exists`;return e||(e=(this.turns.size+1).toString()),this.turns.set(e,t),e}doTurn(t,e=!1){const s=this.turns.get(t);if(!s)throw`Unknown turn ${t}`;let i=e?1:0,r=e?0:1,o={};s.forEach((t=>{o[t[r]]=this.stickers.get(t[r]),this.stickers.set(t[r],o[t[i]]||this.stickers.get(t[i]))}))}isSolved(){const t=this.faces.entries();let e=t.next();do{const s=e.value[1];let i=this.stickers.get(s[0]);for(let t of s)if(i!=this.stickers.get(t))return!1;e=t.next()}while(!e.done);return!0}getValues(){let t={};return this.faces.forEach(((e,s)=>{t[s]=e.map((t=>this.stickers.get(t)))})),t}setValue(t,e,s){if(!this.faces.has(t))return void console.warn(`attempting to set sticker value on invalid face: ${t}`);let i=this.faces.get(t),r=i[e];i?this.stickers.set(r,s):console.warn(`attempting to set sticker value for invalid sticker: ${t} ${e}`)}alg(t){t&&t.split(" ").forEach((t=>this.doTurn(t)))}case(t){}reset(){this.faces.forEach(((t,e)=>{t.forEach((t=>{this.stickers.set(t,e)}))}))}}const f={value:"#FFFF00"},m={value:"#FF0000"},v={value:"#0000FF"},p={value:"#FFFFFF"},b={value:"#FFA500"},g={value:"#00FF00"},w={value:"#800080"},y={value:"#808080"},E={value:"#00008B"},S={value:"#ffffb3"},k={value:"#32CD32"},C={value:"#FF69B4"},R={value:"#000000"},F={value:"#404040"},M={value:"#FFFF00",stroke:"#DDDD00"},L={value:"#FF0000",stroke:"#DD0000"},x={value:"#0000FF",stroke:"#0000DD"},P={value:"#FFFFFF",stroke:"#DDD"},T={value:"#FFA500",stroke:"#DD8500"},V={value:"#00FF00",stroke:"#00DD00"},B={value:"#800080",stroke:"#5c005c"},I={value:"#808080",stroke:"#6b6b6b"},N={value:"#00008B",stroke:"#000075"},_={value:"#ffffb3",stroke:"#e6e6a3"},z={value:"#32CD32",stroke:"#2db32d"},U={value:"#FF69B4",stroke:"#de5b9c"};var A;!function(t){t[t.CORNER=0]="CORNER",t[t.EDGE=1]="EDGE",t[t.MIDDLE=2]="MIDDLE"}(A||(A={}));class vector_Vector3{constructor(t,e,s){this.x=t,this.y=e,this.z=s}static fromValues(t,e,s){return new vector_Vector3(t,e,s)}transformMat4(t){let e=t.values[3]*this.x+t.values[7]*this.y+t.values[11]*this.z+t.values[15];e=e||1;const s=(t.values[0]*this.x+t.values[4]*this.y+t.values[8]*this.z+t.values[12])/e,i=(t.values[1]*this.x+t.values[5]*this.y+t.values[9]*this.z+t.values[13])/e,r=(t.values[2]*this.x+t.values[6]*this.y+t.values[10]*this.z+t.values[14])/e;this.x=s,this.y=i,this.z=r}multiply(t,e,s){this.x=this.x*t,this.y=this.y*e,this.z=this.z*s}rotateX(t,e){let s=this.x-t.x,i=this.y-t.y,r=this.z-t.z;return this.x=s,this.y=i*Math.cos(e)-r*Math.sin(e),this.z=i*Math.sin(e)+r*Math.cos(e),this.x+=t.x,this.y+=t.y,this.z+=t.z,this}rotateZ(t,e){let s=this.x-t.x,i=this.y-t.y,r=this.z-t.z;return this.x=s*Math.cos(e)-i*Math.sin(e),this.y=s*Math.sin(e)+i*Math.cos(e),this.z=r,this.x+=t.x,this.y+=t.y,this.z+=t.z,this}clone(){return vector_Vector3.fromValues(this.x,this.y,this.z)}}class Vector2{constructor(t,e){this.x=t,this.y=e}static fromValues(t,e){return new Vector2(t,e)}}const D=vector_Vector3.fromValues(.92875,-.24803,0),G=f,O=p,W=m,j=v,$=g,X=b,q={top:G,front:W,bottom:O,left:j,right:$,back:X},H=[{type:A.CORNER,colors:[G,W,j]},{type:A.EDGE,colors:[G,j]},{type:A.CORNER,colors:[G,j,X]},{type:A.EDGE,colors:[G,X]},{type:A.CORNER,colors:[G,X,$]},{type:A.EDGE,colors:[G,$]},{type:A.CORNER,colors:[G,$,W]},{type:A.EDGE,colors:[G,W]}],Y=[{type:A.EDGE,colors:[O,X]},{type:A.CORNER,colors:[O,X,j]},{type:A.EDGE,colors:[O,j]},{type:A.CORNER,colors:[O,j,W]},{type:A.EDGE,colors:[O,W]},{type:A.CORNER,colors:[O,W,$]},{type:A.EDGE,colors:[O,$]},{type:A.CORNER,colors:[O,$,X]}],K=/((\()?(-?\d)\s*,\s*(-?\d)(\))?)|(\/)/g;function Z(t){let e,s=[];for(;e=K.exec(t);)"/"===e[0]?s.push({slice:!0}):s.push({top:parseInt(e[3]),bottom:parseInt(e[4])});return s}const Q={[A.CORNER]:2,[A.EDGE]:1};class Square1Simualtor extends Simulator{constructor(t=q){super(),this.scheme=t,this.topLayer=function(t){return[{type:A.CORNER,colors:[t.top||G,t.front||W,t.left||j]},{type:A.EDGE,colors:[t.top||G,t.left||j]},{type:A.CORNER,colors:[t.top||G,t.left||j,t.back||X]},{type:A.EDGE,colors:[t.top||G,t.back||X]},{type:A.CORNER,colors:[t.top||G,t.back||X,t.right||$]},{type:A.EDGE,colors:[t.top||G,t.right||$]},{type:A.CORNER,colors:[t.top||G,t.right||$,t.front||W]},{type:A.EDGE,colors:[t.top||G,t.front||W]}]}(this.scheme),this.bottomLayer=function(t){return[{type:A.EDGE,colors:[t.bottom||O,t.back||X]},{type:A.CORNER,colors:[t.bottom||O,t.back||X,t.left||j]},{type:A.EDGE,colors:[t.bottom||O,t.left||j]},{type:A.CORNER,colors:[t.bottom||O,t.left||j,t.front||W]},{type:A.EDGE,colors:[t.bottom||O,t.front||W]},{type:A.CORNER,colors:[t.bottom||O,t.front||W,t.right||$]},{type:A.EDGE,colors:[t.bottom||O,t.right||$]},{type:A.CORNER,colors:[t.bottom||O,t.right||$,t.back||X]}]}(this.scheme),this.middleRotated=!1}alg(t){Z(t).forEach((t=>{"slice"in t?this.slice():(this.rotateTop(t.top),this.rotateBottom(t.bottom))}))}case(t){Z(t).reverse().forEach((t=>{"slice"in t?this.slice():(this.rotateTop(-1*t.top),this.rotateBottom(-1*t.bottom))}))}slice(){let t=0,e=0,s=0;for(let e=this.topLayer.length;e>0&&s<6;e--)s+=Q[this.topLayer[e-1].type],t++;if(6!=s)throw"Cannot perform slice move. Top layer misaligned";s=0;for(let t=this.bottomLayer.length;t>0&&s<6;t--)s+=Q[this.bottomLayer[t-1].type],e++;if(6!=s)throw"Cannot perform slice move. Bottom layer misaligned";const i=this.topLayer.splice(this.topLayer.length-t,this.topLayer.length),r=this.bottomLayer.splice(this.bottomLayer.length-e,this.bottomLayer.length);this.topLayer=this.topLayer.concat(r),this.bottomLayer=this.bottomLayer.concat(i),this.middleRotated=!this.middleRotated}rotateTop(t){const e=t;for(;0!=t;)if(t<0){const s=this.topLayer.shift(),i=Q[s.type];if(Math.abs(t)<i)throw`Invalid Square1 Move. Cannot turn top layer ${e} steps`;this.topLayer.push(s),t+=i}else{const s=this.topLayer.pop(),i=Q[s.type];if(Math.abs(t)<i)throw`Invalid Square1 Move. Cannot turn top layer ${e} steps`;this.topLayer.unshift(s),t-=i}}rotateBottom(t){const e=t;for(;0!=t;)if(t<0){const s=this.bottomLayer.shift(),i=Q[s.type];if(Math.abs(t)<i)throw`Invalid Square1 Move. Cannot turn top layer ${e} steps`;this.bottomLayer.push(s),t+=i}else{const s=this.bottomLayer.pop(),i=Q[s.type];if(Math.abs(t)<i)throw`Invalid Square1 Move. Cannot turn top layer ${e} steps`;this.bottomLayer.unshift(s),t-=i}}}const J=/([LRUB])(\'?)/g,tt={"":s.Clockwise,"'":s.CounterClockwise};function et(t){let e,s=[];for(;e=J.exec(t);){const t=e[1],i=e[2];s.push({unit:t,turnType:tt[i],slices:1})}return s}function st(t,e){return new Array(t).fill(e)}class SkewbSimulator extends Simulator{constructor(){super();const{stickerIds:t}=this.addFace(st(5,"top"),"top"),{stickerIds:e}=this.addFace(st(5,"front"),"front"),{stickerIds:s}=this.addFace(st(5,"right"),"right"),{stickerIds:i}=this.addFace(st(5,"bottom"),"bottom"),{stickerIds:r}=this.addFace(st(5,"back"),"back"),{stickerIds:o}=this.addFace(st(5,"left"),"left");this.addTurn([[s[0],r[0]],[s[2],r[4]],[s[3],r[1]],[s[4],r[3]],[r[0],i[0]],[r[4],i[2]],[r[1],i[3]],[r[3],i[4]],[i[0],s[0]],[i[2],s[2]],[i[3],s[3]],[i[4],s[4]],[e[4],t[2]],[t[2],o[3]],[o[3],e[4]]],"R"),this.addTurn([[it(t),it(o)],[rt(t),rt(o)],[ot(t),ot(o)],[at(t),at(o)],[it(o),it(r)],[rt(o),ot(r)],[ot(o),ht(r)],[at(o),rt(r)],[it(r),it(t)],[ot(r),rt(t)],[ht(r),ot(t)],[rt(r),at(t)],[ot(s),rt(e)],[rt(e),at(i)],[at(i),ot(s)]],"U"),this.addTurn([[it(o),it(e)],[at(o),rt(e)],[ot(o),ht(e)],[ht(o),at(e)],[it(e),it(i)],[rt(e),ot(i)],[ht(e),at(i)],[at(e),rt(i)],[it(i),it(o)],[ot(i),at(o)],[at(i),ot(o)],[rt(i),ht(o)],[ht(r),at(t)],[at(t),at(s)],[at(s),ht(r)]],"L"),this.addTurn([[it(r),it(o)],[ot(r),ht(o)],[at(r),rt(o)],[ht(r),at(o)],[it(o),it(i)],[ht(o),ht(i)],[rt(o),rt(i)],[at(o),at(i)],[it(i),it(r)],[ht(i),ot(r)],[rt(i),at(r)],[at(i),ht(r)],[rt(t),at(e)],[at(e),ht(s)],[ht(s),rt(t)]],"B")}R(t){this.doTurn("R",t)}U(t){this.doTurn("U",t)}L(t){this.doTurn("L",t)}B(t){this.doTurn("B",t)}alg(t){t&&this.doTurns(et(t))}case(t){if(!t)return;let e=et(t).reverse().map((t=>Object.assign(Object.assign({},t),{turnType:t.turnType===s.Clockwise?s.CounterClockwise:s.Clockwise})));this.doTurns(e)}doTurns(t){t.forEach((t=>{let e=t.turnType===s.CounterClockwise;switch(t.unit){case"R":this.R(e);break;case"U":this.U(e);break;case"L":this.L(e);break;case"B":this.B(e)}}))}}const it=t=>t[0],rt=t=>t[1],ot=t=>t[2],at=t=>t[3],ht=t=>t[4],nt=/([LlRrUuBb])(\'?)/g,lt={"":s.Clockwise,"'":s.CounterClockwise};function ct(t){let e,s=[];for(;e=nt.exec(t);){const t=e[1],i=e[2];s.push({unit:t,turnType:lt[i],slices:1})}return s}class PyraminxSimulator extends Simulator{constructor(){super();const{stickerIds:t}=this.addFace(st(9,"top"),"top"),{stickerIds:e}=this.addFace(st(9,"left"),"left"),{stickerIds:s}=this.addFace(st(9,"right"),"right"),{stickerIds:i}=this.addFace(st(9,"back"),"back");this.addTurn([[t[8],s[8]],[s[8],e[8]],[e[8],t[8]]],"u"),this.addTurn([[e[0],i[8]],[i[8],t[4]],[t[4],e[0]]],"l"),this.addTurn([[e[4],s[0]],[s[0],i[4]],[i[4],e[4]]],"r"),this.addTurn([[s[4],t[0]],[t[0],i[0]],[i[0],s[4]]],"b"),this.addTurn([[t[5],s[5]],[t[6],s[6]],[t[7],s[7]],[t[8],s[8]],[s[5],e[5]],[s[6],e[6]],[s[7],e[7]],[s[8],e[8]],[e[5],t[5]],[e[6],t[6]],[e[7],t[7]],[e[8],t[8]]],"U"),this.addTurn([[e[0],i[8]],[e[1],i[6]],[e[2],i[5]],[e[5],i[7]],[i[8],t[4]],[i[6],t[3]],[i[5],t[7]],[i[7],t[2]],[t[4],e[0]],[t[3],e[1]],[t[7],e[2]],[t[2],e[5]]],"L"),this.addTurn([[e[2],s[5]],[e[3],s[1]],[e[4],s[0]],[e[7],s[2]],[s[5],i[2]],[s[1],i[3]],[s[0],i[4]],[s[2],i[7]],[i[2],e[2]],[i[3],e[3]],[i[4],e[4]],[i[7],e[7]]],"R"),this.addTurn([[s[2],t[5]],[s[3],t[1]],[s[4],t[0]],[s[7],t[2]],[t[5],i[5]],[t[1],i[1]],[t[0],i[0]],[t[2],i[2]],[i[5],s[2]],[i[1],s[3]],[i[0],s[4]],[i[2],s[7]]],"B")}U(t){this.doTurn("U",t)}R(t){this.doTurn("R",t)}L(t){this.doTurn("L",t)}B(t){this.doTurn("B",t)}u(t){this.doTurn("u",t)}r(t){this.doTurn("r",t)}l(t){this.doTurn("l",t)}b(t){this.doTurn("b",t)}alg(t){t&&this.doTurns(ct(t))}case(t){if(!t)return;let e=ct(t).reverse().map((t=>Object.assign(Object.assign({},t),{turnType:t.turnType===s.Clockwise?s.CounterClockwise:s.Clockwise})));this.doTurns(e)}doTurns(t){t.forEach((t=>{let e=t.turnType===s.CounterClockwise;switch(t.unit){case"R":this.R(e);break;case"r":this.r(e);break;case"U":this.U(e);break;case"u":this.u(e);break;case"L":this.L(e);break;case"l":this.l(e);break;case"B":this.B(e);break;case"b":this.b(e)}}))}}const ut=["U","R","F","dr","dl","L","d","br","BR","BL","bl","b"],dt=/([RD])([\+\+|\-\-]+)|([UFRL]|BR|BL)([2-3]?)(\'?)/g;var ft;!function(t){t.Clockwise="++",t.CounterClockwise="--",t.FaceClockwise="",t.FaceCounter="'"}(ft||(ft={}));const mt={[ft.Clockwise]:s.Clockwise,[ft.CounterClockwise]:s.CounterClockwise,[ft.FaceClockwise]:s.Clockwise,[ft.FaceCounter]:s.CounterClockwise};function vt(t){if(!t)return[];let e,s=[];for(;e=dt.exec(t);){const t=e[1]?`${e[1]}xx`:e[3],i=e[2]||e[5],r=e[4];s.push({unit:t,turnType:mt[i],slices:1,n:r?parseInt(r):1})}return s}class MegaminxSimulator extends Simulator{constructor(){super(),ut.forEach((t=>{this.addFace(st(11,t),t)}));const t=this.faces.get("U"),e=this.faces.get("R"),s=this.faces.get("F"),i=this.faces.get("dr"),r=this.faces.get("dl"),o=this.faces.get("L"),a=this.faces.get("d"),h=this.faces.get("br"),n=this.faces.get("BR"),l=this.faces.get("BL"),c=this.faces.get("bl"),u=this.faces.get("b");this.addTurn([[s[2],t[6]],[s[1],t[5]],[s[10],t[4]],[t[6],n[10]],[t[5],n[9]],[t[4],n[8]],[n[10],h[8]],[n[9],h[7]],[n[8],h[6]],[h[8],i[2]],[h[7],i[1]],[h[6],i[10]],[i[2],s[2]],[i[1],s[1]],[i[10],s[10]],...pt(e)],"R"),this.addTurn([[t[2],e[2]],[t[3],e[3]],[t[4],e[4]],[e[2],i[2]],[e[3],i[3]],[e[4],i[4]],[i[2],r[2]],[i[3],r[3]],[i[4],r[4]],[r[2],o[2]],[r[3],o[3]],[r[4],o[4]],[o[2],t[2]],[o[3],t[3]],[o[4],t[4]],...pt(s)],"F"),this.addTurn([[s[2],o[4]],[s[3],o[5]],[s[4],o[6]],[o[4],l[8]],[o[5],l[9]],[o[6],l[10]],[l[8],n[6]],[l[9],n[7]],[l[10],n[8]],[n[6],e[10]],[n[7],e[1]],[n[8],e[2]],[e[10],s[2]],[e[1],s[3]],[e[2],s[4]],...pt(t)],"U"),this.addTurn([[s[4],r[4]],[s[5],r[5]],[s[6],r[6]],[r[4],c[8]],[r[5],c[9]],[r[6],c[10]],[c[8],l[6]],[c[9],l[7]],[c[10],l[8]],[l[6],t[10]],[l[7],t[1]],[l[8],t[2]],[t[10],s[4]],[t[1],s[5]],[t[2],s[6]],...pt(o)],"L"),this.addTurn([[t[6],l[10]],[t[7],l[1]],[t[8],l[2]],[l[10],u[8]],[l[1],u[9]],[l[2],u[10]],[u[8],h[4]],[u[9],h[5]],[u[10],h[6]],[h[4],e[8]],[h[5],e[9]],[h[6],e[10]],[e[8],t[6]],[e[9],t[7]],[e[10],t[8]],...pt(n)],"BR"),this.addTurn([[t[8],o[6]],[t[9],o[7]],[t[10],o[8]],[o[6],c[10]],[o[7],c[1]],[o[8],c[2]],[c[10],u[6]],[c[1],u[7]],[c[2],u[8]],[u[6],n[4]],[u[7],n[5]],[u[8],n[6]],[n[4],t[8]],[n[5],t[9]],[n[6],t[10]],...pt(l)],"BL"),this.addTurn([[s[8],e[4]],[s[9],e[5]],[s[10],e[6]],[e[4],h[8]],[e[5],h[9]],[e[6],h[10]],[h[8],a[6]],[h[9],a[7]],[h[10],a[8]],[a[6],r[10]],[a[7],r[1]],[a[8],r[2]],[r[10],s[8]],[r[1],s[9]],[r[2],s[10]],...pt(i)],"dr"),this.addTurn([[s[6],i[4]],[s[7],i[5]],[s[8],i[6]],[i[4],a[8]],[i[5],a[9]],[i[6],a[10]],[a[8],c[6]],[a[9],c[7]],[a[10],c[8]],[c[6],o[10]],[c[7],o[1]],[c[8],o[2]],[o[10],s[6]],[o[1],s[7]],[o[2],s[8]],...pt(r)],"dl"),this.addTurn([[h[10],u[2]],[h[1],u[3]],[h[2],u[4]],[u[2],c[4]],[u[3],c[5]],[u[4],c[6]],[c[4],r[8]],[c[5],r[9]],[c[6],r[10]],[r[8],i[6]],[r[9],i[7]],[r[10],i[8]],[i[6],h[10]],[i[7],h[1]],[i[8],h[2]],...pt(a)],"d"),this.addTurn([[u[10],a[4]],[u[1],a[5]],[u[2],a[6]],[a[4],i[8]],[a[5],i[9]],[a[6],i[10]],[i[8],e[6]],[i[9],e[7]],[i[10],e[8]],[e[6],n[10]],[e[7],n[1]],[e[8],n[2]],[n[10],u[10]],[n[1],u[1]],[n[2],u[2]],...pt(h)],"br"),this.addTurn([[l[4],o[8]],[l[5],o[9]],[l[6],o[10]],[o[8],r[6]],[o[9],r[7]],[o[10],r[8]],[r[6],a[10]],[r[7],a[1]],[r[8],a[2]],[a[10],u[4]],[a[1],u[5]],[a[2],u[6]],[u[4],l[4]],[u[5],l[5]],[u[6],l[6]],...pt(c)],"bl"),this.addTurn([[h[2],n[2]],[h[3],n[3]],[h[4],n[4]],[n[2],l[2]],[n[3],l[3]],[n[4],l[4]],[l[2],c[2]],[l[3],c[3]],[l[4],c[4]],[c[2],a[2]],[c[3],a[3]],[c[4],a[4]],[a[2],h[2]],[a[3],h[3]],[a[4],h[4]],...pt(u)],"b"),this.addTurn([[s[0],e[0]],[s[1],e[9]],[s[5],e[3]],[s[6],e[4]],[s[7],e[5]],[s[8],e[6]],[s[9],e[7]],[s[10],e[8]],[e[0],n[0]],[e[3],n[9]],[e[4],n[10]],[e[5],n[1]],[e[6],n[2]],[e[7],n[3]],[e[8],n[4]],[e[9],n[5]],[n[0],l[0]],[n[9],l[1]],[n[10],l[2]],[n[1],l[3]],[n[2],l[4]],[n[3],l[5]],[n[4],l[6]],[n[5],l[7]],[l[0],o[0]],[l[1],o[7]],[l[2],o[8]],[l[3],o[9]],[l[4],o[10]],[l[5],o[1]],[l[6],o[2]],[l[7],o[3]],[o[0],s[0]],[o[7],s[5]],[o[8],s[6]],[o[9],s[7]],[o[10],s[8]],[o[1],s[9]],[o[2],s[10]],[o[3],s[1]],[i[0],h[0]],[i[1],h[5]],[i[2],h[6]],[i[3],h[7]],[i[4],h[8]],[i[5],h[9]],[i[6],h[10]],[i[7],h[1]],[i[8],h[2]],[i[9],h[3]],[i[10],h[4]],[h[0],u[0]],[h[1],u[3]],[h[2],u[4]],[h[3],u[5]],[h[4],u[6]],[h[5],u[7]],[h[6],u[8]],[h[7],u[9]],[h[8],u[10]],[h[9],u[1]],[h[10],u[2]],[u[0],c[0]],[u[1],c[3]],[u[2],c[4]],[u[3],c[5]],[u[4],c[6]],[u[5],c[7]],[u[6],c[8]],[u[7],c[9]],[u[8],c[10]],[u[9],c[1]],[u[10],c[2]],[c[0],r[0]],[c[1],r[5]],[c[2],r[6]],[c[3],r[7]],[c[4],r[8]],[c[5],r[9]],[c[6],r[10]],[c[7],r[1]],[c[8],r[2]],[c[9],r[3]],[c[10],r[4]],[r[0],i[0]],[r[1],i[9]],[r[2],i[10]],[r[3],i[1]],[r[4],i[2]],[r[5],i[3]],[r[6],i[4]],[r[7],i[5]],[r[8],i[6]],[r[9],i[7]],[r[10],i[8]],...pt(a)],"D++"),this.addTurn([[s[0],t[0]],[s[7],t[3]],[s[8],t[4]],[s[9],t[5]],[s[10],t[6]],[s[1],t[7]],[s[2],t[8]],[s[3],t[9]],[t[0],l[0]],[t[3],l[9]],[t[4],l[10]],[t[5],l[1]],[t[6],l[2]],[t[7],l[3]],[t[8],l[4]],[t[9],l[5]],[l[0],c[0]],[l[9],c[1]],[l[10],c[2]],[l[1],c[3]],[l[2],c[4]],[l[3],c[5]],[l[4],c[6]],[l[5],c[7]],[c[0],r[0]],[c[1],r[7]],[c[2],r[8]],[c[3],r[9]],[c[4],r[10]],[c[5],r[1]],[c[6],r[2]],[c[7],r[3]],[r[0],s[0]],[r[7],s[7]],[r[8],s[8]],[r[9],s[9]],[r[10],s[10]],[r[1],s[1]],[r[2],s[2]],[r[3],s[3]],[i[0],e[0]],[i[1],e[9]],[i[2],e[10]],[i[3],e[1]],[i[4],e[2]],[i[5],e[3]],[i[6],e[4]],[i[7],e[5]],[i[8],e[6]],[i[9],e[7]],[i[10],e[8]],[e[0],n[0]],[e[1],n[5]],[e[2],n[6]],[e[3],n[7]],[e[4],n[8]],[e[5],n[9]],[e[6],n[10]],[e[7],n[1]],[e[8],n[2]],[e[9],n[3]],[e[10],n[4]],[n[0],u[0]],[n[1],u[1]],[n[2],u[2]],[n[3],u[3]],[n[4],u[4]],[n[5],u[5]],[n[6],u[6]],[n[7],u[7]],[n[8],u[8]],[n[9],u[9]],[n[10],u[10]],[u[0],a[0]],[u[1],a[5]],[u[2],a[6]],[u[3],a[7]],[u[4],a[8]],[u[5],a[9]],[u[6],a[10]],[u[7],a[1]],[u[8],a[2]],[u[9],a[3]],[u[10],a[4]],[a[0],i[0]],[a[1],i[5]],[a[2],i[6]],[a[3],i[7]],[a[4],i[8]],[a[5],i[9]],[a[6],i[10]],[a[7],i[1]],[a[8],i[2]],[a[9],i[3]],[a[10],i[4]],...pt(h)],"R++")}U(t){this.doTurn("U",t)}R(t){this.doTurn("R",t)}F(t){this.doTurn("F",t)}dr(t){this.doTurn("dr",t)}dl(t){this.doTurn("dl",t)}L(t){this.doTurn("L",t)}d(t){this.doTurn("d",t)}br(t){this.doTurn("br",t)}BR(t){this.doTurn("BR",t)}BL(t){this.doTurn("BL",t)}bl(t){this.doTurn("bl",t)}b(t){this.doTurn("b",t)}Dxx(t){this.doTurn("D++",t)}Rxx(t){this.doTurn("R++",t)}alg(t){t&&this.doTurns(vt(t))}case(t){if(!t)return;let e=vt(t).reverse().map((t=>Object.assign(Object.assign({},t),{turnType:t.turnType===s.Clockwise?s.CounterClockwise:s.Clockwise})));this.doTurns(e)}doTurns(t){t.forEach((t=>{let e,i=t.turnType===s.CounterClockwise;switch(t.unit){case"Rxx":e=this.Rxx.bind(this);break;case"Dxx":e=this.Dxx.bind(this);break;case"U":e=this.U.bind(this);break;case"R":e=this.R.bind(this);break;case"F":e=this.F.bind(this);break;case"L":e=this.L.bind(this);break;case"BL":e=this.BL.bind(this);break;case"BR":e=this.BR.bind(this)}for(let s=t.n;s>0;s--)e(i)}))}}function pt(t){return[[t[1],t[9]],[t[9],t[7]],[t[7],t[5]],[t[5],t[3]],[t[3],t[1]],[t[2],t[10]],[t[10],t[8]],[t[8],t[6]],[t[6],t[4]],[t[4],t[2]]]}var bt;!function(t){t.U="U",t.R="R",t.F="F",t.D="D",t.L="L",t.B="B"}(bt||(bt={}));const gt=[bt.U,bt.R,bt.F,bt.D,bt.L,bt.B];var wt;!function(t){t.X="X",t.Y="Y",t.Z="Z"}(wt||(wt={}));const yt={X:[bt.U,bt.B,bt.D,bt.F],Y:[bt.L,bt.B,bt.R,bt.F],Z:[bt.L,bt.U,bt.R,bt.D]},Et={X:{[bt.U]:0,[bt.B]:2,[bt.F]:0,[bt.D]:0},Y:{[bt.B]:-1,[bt.F]:-1,[bt.L]:-1,[bt.R]:-1},Z:{[bt.U]:-1,[bt.D]:1,[bt.L]:2,[bt.R]:0}},St={[bt.U]:!1,[bt.R]:!1,[bt.F]:!1,[bt.D]:!0,[bt.L]:!0,[bt.B]:!0};function kt(t){return Math.PI*t/180}function Ct(t,e){const s=t*Math.cos(e),i=t*Math.sin(e);return Vector2.fromValues(s,i)}function Rt(t){return t/2*Math.sqrt(2.5+1.1*Math.sqrt(5))}function Ft(t){let e=0,s=0,i=0;return t.forEach((t=>{e+=t.x,s+=t.y,i+=t.z})),e/=t.length,s/=t.length,i/=t.length,vector_Vector3.fromValues(e,s,i)}class RubiksCubeSimulator extends Simulator{constructor(t){super(),this.size=t,this.gridSize=t*t,gt.forEach((t=>{this.addFace(st(this.gridSize,t),t);const e=this.makeFaceTurnDefinitions(t);this.addTurn(e,t)})),[wt.X,wt.Y,wt.Z].forEach((t=>{for(let e=0;e<this.size;e++){let s=[];yt[t].forEach(((i,r)=>{const o=yt[t][(r+1)%yt[t].length],a=this.faces.get(o),h=this.faces.get(i);for(let r=0;r<this.size;r++){const n=this.size*r+e,l=h[this.axisAlignedSticker(t,i,n)],c=a[this.axisAlignedSticker(t,o,n)];s.push([l,c])}})),this.addTurn(s,`${t}-${e}`)}}))}makeFaceTurnDefinitions(t){const e=this.faces.get(t);return e.map(((t,s)=>[t,e[this.clockwiseSticker(s)]]))}clockwiseSticker(t){return(t+1)*this.size%(this.gridSize+1)-1}counterClockwiseSticker(t){return this.oppositeSticker(this.clockwiseSticker(t))}oppositeSticker(t){return this.gridSize-(t+1)}axisAlignedSticker(t,e,s){switch(Et[t][e]){case 0:return s;case 1:return this.clockwiseSticker(s);case 2:return this.oppositeSticker(s);case-1:return this.counterClockwiseSticker(s);default:throw`Invalid axis face orientation value ${Et[t][e]}`}}turnFace(t,e,s,i,r){Math.abs(r-i)>=this.size-1?console.error(`Invalid number of layers to turn, skipping turn.; face=${t}, layers=${Math.abs(r-i)+1}`):(this.doTurn(t,s),function(t,e){if(t===e)return[t];const s=t<e?1:-1;let i=[];for(let r=t;r!=e;r+=s)i.push(r);return i.push(e),i}(i,r).forEach((i=>{this.doTurn(`${e}-${i}`,St[t]?!s:s)})))}U(t=!1,e=1){this.turnFace(bt.U,wt.Y,t,this.size-1,this.size-e)}R(t=!1,e=1){this.turnFace(bt.R,wt.X,t,this.size-1,this.size-e)}F(t=!1,e=1){this.turnFace(bt.F,wt.Z,t,0,e-1)}D(t=!1,e=1){this.turnFace(bt.D,wt.Y,t,0,e-1)}L(t=!1,e=1){this.turnFace(bt.L,wt.X,t,0,e-1)}B(t=!1,e=1){this.turnFace(bt.B,wt.Z,t,this.size-1,this.size-e)}M(t=!1){for(let e=1;e<this.size-1;e++)this.doTurn(`${wt.X}-${e}`,!t)}S(t=!1){for(let e=1;e<this.size-1;e++)this.doTurn(`${wt.Z}-${e}`,t)}E(t=!1){for(let e=1;e<this.size-1;e++)this.doTurn(`${wt.Y}-${e}`,!t)}X(t=!1){this.doTurn("R",t),this.doTurn("L",!t);for(let e=0;e<this.size;e++)this.doTurn(`${wt.X}-${e}`,t)}Y(t=!1){this.doTurn("U",t),this.doTurn("D",!t);for(let e=0;e<this.size;e++)this.doTurn(`${wt.Y}-${e}`,t)}Z(t=!1){this.doTurn("F",t),this.doTurn("B",!t);for(let e=0;e<this.size;e++)this.doTurn(`${wt.Z}-${e}`,t)}alg(t){t&&this.doTurns(l(t))}case(t){if(!t)return;let e=l(t).reverse().map((t=>{switch(t.turnType){case s.Clockwise:t.turnType=s.CounterClockwise;break;case s.CounterClockwise:t.turnType=s.Clockwise;case s.Double:}return t}));this.doTurns(e)}doTurns(t){t.forEach((t=>{let e;switch(t.unit){case r.U:e=this.U.bind(this);break;case r.R:e=this.R.bind(this);break;case r.F:e=this.F.bind(this);break;case r.D:e=this.D.bind(this);break;case r.L:e=this.L.bind(this);break;case r.B:e=this.B.bind(this);break;case r.M:e=this.M.bind(this);break;case r.E:e=this.E.bind(this);break;case r.S:e=this.S.bind(this);break;case r.X:e=this.X.bind(this);break;case r.Y:e=this.Y.bind(this);break;case r.Z:e=this.Z.bind(this);break;default:console.warn("Unsupported cube move",t)}const i=t.turnType===s.CounterClockwise;e(i,t.slices),t.turnType===s.Double&&e(i,t.slices)}))}}const Mt=(()=>{let t=0;return function(){return t++}})();class Matrix4{constructor(t){Array.isArray(t)&&16==t.length?this.values=t:this.values=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}static fromValues(t,e,s,i,r,o,a,h,n,l,c,u,d,f,m,v){return new Matrix4([t,e,s,i,r,o,a,h,n,l,c,u,d,f,m,v])}static fromQuaternion(t){let{a:e,b:s,c:i,d:r}=t,o=e+e,a=s+s,h=i+i,n=e*o,l=s*o,c=s*a,u=i*o,d=i*a,f=i*h,m=r*o,v=r*a,p=r*h;return Matrix4.fromValues(1-c-f,l+p,u-v,0,l-p,1-n-f,d+m,0,u+v,d-m,1-n-c,0,0,0,0,1)}static fromTranslation(t,e,s){return Matrix4.fromValues(1,0,0,0,0,1,0,0,0,0,1,0,t,e,s,1)}static fromXRotation(t){let e=Math.sin(t),s=Math.cos(t);return Matrix4.fromValues(1,0,0,0,0,s,e,0,0,-e,s,0,0,0,0,1)}static fromYRotation(t){let e=Math.sin(t),s=Math.cos(t);return Matrix4.fromValues(s,0,-e,0,0,1,0,0,e,0,s,0,0,0,0,1)}static copy(t,e){t.values[0]=e.values[0],t.values[1]=e.values[1],t.values[2]=e.values[2],t.values[3]=e.values[3],t.values[4]=e.values[4],t.values[5]=e.values[5],t.values[6]=e.values[6],t.values[7]=e.values[7],t.values[8]=e.values[8],t.values[9]=e.values[9],t.values[10]=e.values[10],t.values[11]=e.values[11],t.values[12]=e.values[12],t.values[13]=e.values[13],t.values[14]=e.values[14],t.values[15]=e.values[15]}static multiply(t,e,s){let i=e.values[0],r=e.values[1],o=e.values[2],a=e.values[3],h=e.values[4],n=e.values[5],l=e.values[6],c=e.values[7],u=e.values[8],d=e.values[9],f=e.values[10],m=e.values[11],v=e.values[12],p=e.values[13],b=e.values[14],g=e.values[15],w=s.values[0],y=s.values[1],E=s.values[2],S=s.values[3];return t.values[0]=w*i+y*h+E*u+S*v,t.values[1]=w*r+y*n+E*d+S*p,t.values[2]=w*o+y*l+E*f+S*b,t.values[3]=w*a+y*c+E*m+S*g,w=s.values[4],y=s.values[5],E=s.values[6],S=s.values[7],t.values[4]=w*i+y*h+E*u+S*v,t.values[5]=w*r+y*n+E*d+S*p,t.values[6]=w*o+y*l+E*f+S*b,t.values[7]=w*a+y*c+E*m+S*g,w=s.values[8],y=s.values[9],E=s.values[10],S=s.values[11],t.values[8]=w*i+y*h+E*u+S*v,t.values[9]=w*r+y*n+E*d+S*p,t.values[10]=w*o+y*l+E*f+S*b,t.values[11]=w*a+y*c+E*m+S*g,w=s.values[12],y=s.values[13],E=s.values[14],S=s.values[15],t.values[12]=w*i+y*h+E*u+S*v,t.values[13]=w*r+y*n+E*d+S*p,t.values[14]=w*o+y*l+E*f+S*b,t.values[15]=w*a+y*c+E*m+S*g,t}static perspective(t,e,s,i){const r=1/Math.tan(t/2),o=[r/e,0,0,0,0,r,0,0,0,0,0,-1,0,0,0,0];if(null!=i&&i!==1/0){const t=1/(s-i);o[10]=(i+s)*t,o[14]=2*i*s*t}else o[10]=-1,o[14]=-2*s;return new Matrix4(o)}translate(t,e,s){this.values[12]=this.values[0]*t+this.values[4]*e+this.values[8]*s+this.values[12],this.values[13]=this.values[1]*t+this.values[5]*e+this.values[9]*s+this.values[13],this.values[14]=this.values[2]*t+this.values[6]*e+this.values[10]*s+this.values[14],this.values[15]=this.values[3]*t+this.values[7]*e+this.values[11]*s+this.values[15]}scale(t,e,s){this.values[0]=this.values[0]*t,this.values[1]=this.values[1]*t,this.values[2]=this.values[2]*t,this.values[3]=this.values[3]*t,this.values[4]=this.values[4]*e,this.values[5]=this.values[5]*e,this.values[6]=this.values[6]*e,this.values[7]=this.values[7]*e,this.values[8]=this.values[8]*s,this.values[9]=this.values[9]*s,this.values[10]=this.values[10]*s,this.values[11]=this.values[11]*s}rotate(t,e,s,i){let r=Math.hypot(e,s,i);if(r<1e-6)return;r=1/r,e*=r,s*=r,i*=r;let o,a,h,n,l,c,u,d,f,m,v,p,b,g,w,y,E,S,k,C,R,F=Math.sin(t),M=Math.cos(t),L=1-M;o=this.values[0],a=this.values[1],h=this.values[2],n=this.values[3],l=this.values[4],c=this.values[5],u=this.values[6],d=this.values[7],f=this.values[8],m=this.values[9],v=this.values[10],p=this.values[11],b=e*e*L+M,g=s*e*L+i*F,w=i*e*L-s*F,y=e*s*L-i*F,E=s*s*L+M,S=i*s*L+e*F,k=e*i*L+s*F,C=s*i*L-e*F,R=i*i*L+M,this.values[0]=o*b+l*g+f*w,this.values[1]=a*b+c*g+m*w,this.values[2]=h*b+u*g+v*w,this.values[3]=n*b+d*g+p*w,this.values[4]=o*y+l*E+f*S,this.values[5]=a*y+c*E+m*S,this.values[6]=h*y+u*E+v*S,this.values[7]=n*y+d*E+p*S,this.values[8]=o*k+l*C+f*R,this.values[9]=a*k+c*C+m*R,this.values[10]=h*k+u*C+v*R,this.values[11]=n*k+d*C+p*R}multiply(t){Matrix4.multiply(this,this,t)}}class Object3D{constructor(){this.uid=Mt(),this.matrix=new Matrix4,this.centroid=vector_Vector3.fromValues(0,0,0)}translate(t,e,s){this.matrix.translate(t,e,s)}rotate(t,e,s,i){this.matrix.rotate(t,e,s,i)}scale(t,e,s){this.matrix.scale(t,e,s)}setColor(t){this.color=t}}class Group extends Object3D{constructor(t=[]){super(),this.setObjects(t)}setObjects(t){this.objects=t}addObject(t){this.objects.push(t)}setCentroid(t){this.centroid=t}}const Lt=Math.sqrt(3),xt=Math.atan(kt(15)),Pt=kt(30),Tt=(kt(36),kt(60));kt(72);class Square1Builder{constructor(t=H,e=Y,s=!1,i=q,r=.7){this.scheme=i,this.sideLength=r,this.halfSide=this.sideLength/2,this.halfEdgePiece=this.halfSide*xt,this.layerWidth=this.halfSide-this.halfEdgePiece,this.middleWidth=this.sideLength-2*this.layerWidth,this.halfMiddleWidth=this.middleWidth/2,this.borderLayerWidth=.2*this.sideLength,this.outerHalfSide=(r+this.borderLayerWidth)/2,this.outerHalfEdgePiece=this.outerHalfSide*xt,this.pieces=this.buildSquare1(t,e,s),this.group=new Group(this.pieces)}makeLayer(t){let e=[],s=Math.PI;return t.forEach(((t,i)=>{switch(t.type){case A.CORNER:const i=this.square1Corner(t.colors[0],t.colors[1],t.colors[2]);i.rotate(s,0,0,1),e.push(i),s-=Tt;break;case A.EDGE:const r=this.square1Edge(t.colors[0],t.colors[1]);r.rotate(s-Tt,0,0,1),e.push(r),s-=Pt}})),e}setColors(t){}}class Face{constructor(t,e,s){this.indices=t,this.color=s,this.uid=Mt(),e&&this.calculateCentroid(e)}calculateCentroid(t){this.centroid=Ft(t.filter(((t,e)=>this.indices.includes(e))))}}class Geometry extends Object3D{constructor(t,e){super(),this.vertices=t,this.faces=e,this.centroid=Ft(this.vertices)}}class Square1Net extends Square1Builder{constructor(t=H,e=Y,s=!1,i=q,r=.7){super(t,e,s,i,r)}square1Corner(t,e,s){const i=[vector_Vector3.fromValues(0,0,0),vector_Vector3.fromValues(this.halfSide,this.halfEdgePiece,0),vector_Vector3.fromValues(this.halfSide,this.halfSide,0),vector_Vector3.fromValues(this.halfEdgePiece,this.halfSide,0),vector_Vector3.fromValues(this.outerHalfSide,this.outerHalfEdgePiece,0),vector_Vector3.fromValues(this.outerHalfSide,this.outerHalfSide,0),vector_Vector3.fromValues(this.outerHalfEdgePiece,this.outerHalfSide,0)],r=[new Face([0,1,2,3],i,t),new Face([2,3,6,5],i,e),new Face([1,2,5,4],i,s)];return new Geometry(i,r)}square1Edge(t,e){const s=[vector_Vector3.fromValues(0,0,0).rotateZ(vector_Vector3.fromValues(0,0,0),Pt),vector_Vector3.fromValues(this.halfEdgePiece,this.halfSide,0).rotateZ(vector_Vector3.fromValues(0,0,0),Pt),vector_Vector3.fromValues(-this.halfEdgePiece,this.halfSide,0).rotateZ(vector_Vector3.fromValues(0,0,0),Pt),vector_Vector3.fromValues(this.outerHalfEdgePiece,this.outerHalfSide,0).rotateZ(vector_Vector3.fromValues(0,0,0),Pt),vector_Vector3.fromValues(-this.outerHalfEdgePiece,this.outerHalfSide,0).rotateZ(vector_Vector3.fromValues(0,0,0),Pt)],i=[new Face([0,1,2],s,t),new Face([1,2,4,3],s,e)];return new Geometry(s,i)}square1Middle(t,e,s,i){const r=this.halfSide-this.halfEdgePiece,o=(this.sideLength-2*r)/2,a=this.outerHalfSide-this.outerHalfEdgePiece,h=[vector_Vector3.fromValues(-this.outerHalfSide,o,-.01),vector_Vector3.fromValues(-this.outerHalfEdgePiece,o,-.01),vector_Vector3.fromValues(this.outerHalfSide,o,-.01),vector_Vector3.fromValues(-this.outerHalfSide,-o,-.01),vector_Vector3.fromValues(-this.outerHalfEdgePiece,-o,-.01),vector_Vector3.fromValues(this.outerHalfSide,-o,-.01),vector_Vector3.fromValues(2*this.outerHalfEdgePiece,o,-.01),vector_Vector3.fromValues(2*this.outerHalfEdgePiece,-o,-.01),vector_Vector3.fromValues(2*a,o,-.01),vector_Vector3.fromValues(2*a,-o,-.01)],n=[new Face([0,1,4,3],h,t)];return i?(n.push(new Face([1,6,7,4],h,s)),n.push(new Face([6,8,9,7],h,e))):n.push(new Face([1,2,5,4],h,t)),new Geometry(h,n)}buildSquare1(t,e,s){const i=this.halfSide-this.halfEdgePiece,r=(this.sideLength-2*i)/2;let o=[];const a=new Group(this.makeLayer(t)),h=new Group(this.makeLayer(e));a.translate(0,this.outerHalfSide+r,0),h.translate(0,-(this.outerHalfSide+r),0),h.rotate(Pt,0,0,1),o=[a,h];const n=this.scheme.front||q.front,l=this.scheme.left||q.left,c=this.scheme.back||q.back,u=this.square1Middle(n,l,c,s);return this.faces={top:a,bottom:h},o.push(u),o}}const Vt={value:"#333",stroke:"#333"};class Square1 extends Square1Builder{constructor(t=H,e=Y,s=!1,i=q,r=1.25){super(t,e,s,i,r)}square1Corner(t,e,s){const i=[vector_Vector3.fromValues(0,0,this.halfSide),vector_Vector3.fromValues(this.halfSide,this.halfEdgePiece,this.halfSide),vector_Vector3.fromValues(this.halfSide,this.halfSide,this.halfSide),vector_Vector3.fromValues(this.halfEdgePiece,this.halfSide,this.halfSide),vector_Vector3.fromValues(0,0,this.halfSide-this.layerWidth),vector_Vector3.fromValues(this.halfSide,this.halfEdgePiece,this.halfSide-this.layerWidth),vector_Vector3.fromValues(this.halfSide,this.halfSide,this.halfSide-this.layerWidth),vector_Vector3.fromValues(this.halfEdgePiece,this.halfSide,this.halfSide-this.layerWidth)],r=[new Face([0,1,2,3],i,t),new Face([4,5,6,7],i,Vt),new Face([0,1,5,4],i,Vt),new Face([2,3,7,6],i,e),new Face([1,2,6,5],i,s),new Face([0,3,7,4],i,Vt)],o=vector_Vector3.fromValues(this.halfSide/2,this.halfSide/2,this.halfSide/2);return r[1].centroid=o,r[2].centroid=o,r[5].centroid=o,new Geometry(i,r)}square1Edge(t,e){const s=[vector_Vector3.fromValues(0,0,this.halfSide).rotateZ(vector_Vector3.fromValues(0,0,0),Pt),vector_Vector3.fromValues(this.halfEdgePiece,this.halfSide,this.halfSide).rotateZ(vector_Vector3.fromValues(0,0,0),Pt),vector_Vector3.fromValues(-this.halfEdgePiece,this.halfSide,this.halfSide).rotateZ(vector_Vector3.fromValues(0,0,0),Pt),vector_Vector3.fromValues(0,0,this.halfSide-this.layerWidth).rotateZ(vector_Vector3.fromValues(0,0,0),Pt),vector_Vector3.fromValues(this.halfEdgePiece,this.halfSide,this.halfSide-this.layerWidth).rotateZ(vector_Vector3.fromValues(0,0,0),Pt),vector_Vector3.fromValues(-this.halfEdgePiece,this.halfSide,this.halfSide-this.layerWidth).rotateZ(vector_Vector3.fromValues(0,0,0),Pt)],i=[new Face([0,1,2],s,t),new Face([3,4,5],s,Vt),new Face([1,2,5,4],s,e),new Face([0,1,4,3],s,Vt),new Face([0,2,5,3],s,Vt)],r=vector_Vector3.fromValues(0,this.halfSide/2,this.halfSide/2).rotateZ(vector_Vector3.fromValues(0,0,0),Pt);return i[1].centroid=r,i[3].centroid=r,i[4].centroid=r,new Geometry(s,i)}square1Middle(t,e,s){const i=[vector_Vector3.fromValues(-this.halfSide,-this.halfSide,this.halfMiddleWidth),vector_Vector3.fromValues(-this.halfSide,this.halfSide,this.halfMiddleWidth),vector_Vector3.fromValues(this.halfEdgePiece,this.halfSide,this.halfMiddleWidth),vector_Vector3.fromValues(-this.halfEdgePiece,-this.halfSide,this.halfMiddleWidth),vector_Vector3.fromValues(-this.halfSide,-this.halfSide,-this.halfMiddleWidth),vector_Vector3.fromValues(-this.halfSide,this.halfSide,-this.halfMiddleWidth),vector_Vector3.fromValues(this.halfEdgePiece,this.halfSide,-this.halfMiddleWidth),vector_Vector3.fromValues(-this.halfEdgePiece,-this.halfSide,-this.halfMiddleWidth)],r=[new Face([0,1,2,3],i,{value:"#333"}),new Face([4,5,6,7],i,{value:"#333"}),new Face([0,1,5,4],i,e),new Face([1,2,6,5],i,s),new Face([0,3,7,4],i,t)],o=vector_Vector3.fromValues(-this.halfSide/2,0,0);return r[0].centroid=o,r[1].centroid=o,r[2].centroid=vector_Vector3.fromValues(-(this.halfSide+.45*this.halfSide),0,0),new Geometry(i,r)}buildSquare1(t,e,s){const i=new Group(this.makeLayer(t)),r=new Group(this.makeLayer(e));r.rotate(Math.PI,1,0,0),r.rotate(Pt,0,0,1);const o=[i,r],a=this.scheme.front||q.front,h=this.scheme.left||q.left,n=this.scheme.back||q.back,l=this.scheme.right||q.right,c=this.square1Middle(a,h,n),u=this.square1Middle(n,l,a);return u.rotate(Math.PI,0,0,1),s&&u.rotate(Math.PI,D.x,D.y,D.z),o.push(c),o.push(u),this.faces={top:i,bottom:r},o}}class Plane extends Geometry{constructor(t,e,s){let i=[vector_Vector3.fromValues(0,0,0),vector_Vector3.fromValues(t,0,0),vector_Vector3.fromValues(t,-e,0),vector_Vector3.fromValues(0,-e,0)];super(i,[new Face([0,1,2,3],i,s)])}}class Triangle extends Geometry{constructor(t,e,s,i){let r=[t,e,s];super(r,[new Face([0,1,2],r,i)])}}class SkewbNet{constructor(){const t=Math.sqrt(2*Math.pow(.5,2)),e=new Group(this.makeStickers(b,t,vector_Vector3.fromValues(-1,0,0))),s=new Group(this.makeStickers(g,t,vector_Vector3.fromValues(2,0,0))),i=new Group(this.makeStickers(p,t,vector_Vector3.fromValues(0,-1,0))),r=new Group(this.makeStickers(m,t,vector_Vector3.fromValues(1,0,0))),o=new Group(this.makeStickers(f,t,vector_Vector3.fromValues(0,1,0))),a=new Group(this.makeStickers(v,t,vector_Vector3.fromValues(0,0,0)));this.U=o,this.R=r,this.F=a,this.L=e,this.B=s,this.D=i,this.faces={top:this.U,front:this.F,right:this.R,back:this.B,left:this.L,bottom:this.D},this.stickers=[r,o,a,e,s,i],this.group=new Group(this.stickers),this.group.translate(-1/4,0,0),this.group.scale(.5,.5,.5)}makeStickers(t,e,s){const i=new Plane(e,e,t);i.translate(s.x,s.y,s.z),i.rotate(Math.PI/4,0,0,1),i.translate(-e/2,e/2,0);const r=[];for(let i=0;i<4;i++){const o=new Triangle(vector_Vector3.fromValues(-e/2,e/2,0),vector_Vector3.fromValues(0,e,0),vector_Vector3.fromValues(e/2,e/2,0),t);o.translate(s.x,s.y,s.z),o.rotate(-Math.PI/2*i,0,0,1),o.rotate(Math.PI/4,0,0,1),r.push(o)}return[i,...r]}setColors(t){let{top:e,right:s,front:i,bottom:r,left:o,back:a}=t;this.setFaceColors(this.U,e),this.setFaceColors(this.R,s),this.setFaceColors(this.F,i),this.setFaceColors(this.D,r),this.setFaceColors(this.L,o),this.setFaceColors(this.B,a)}setFaceColors(t,e=[]){t.objects[0].faces[0].color=e[0]||R,t.objects[1].faces[0].color=e[1]||R,t.objects[2].faces[0].color=e[2]||R,t.objects[3].faces[0].color=e[4]||R,t.objects[4].faces[0].color=e[3]||R}}class Skewb{constructor(){const t=Math.sqrt(2*Math.pow(.625,2)),e=.625,s=new Group(this.makeStickers(m,t)),i=new Group(this.makeStickers(f,t,vector_Vector3.fromValues(1,0,0))),r=new Group(this.makeStickers(v,t,vector_Vector3.fromValues(0,1,0))),o=new Group(this.makeStickers(b,t)),a=new Group(this.makeStickers(g,t,vector_Vector3.fromValues(0,1,0))),h=new Group(this.makeStickers(p,t,vector_Vector3.fromValues(1,0,0)));this.U=i,this.R=s,this.F=r,this.L=o,this.B=a,this.D=h,this.faces={top:this.U,front:this.F,right:this.R,back:this.B,left:this.L,bottom:this.D},s.translate(0,0,e),s.rotate(Math.PI,1,0,0),s.rotate(Math.PI/2,0,0,1),o.rotate(-Math.PI/2,0,0,1),o.translate(0,0,-.625),r.rotate(-Math.PI/2,1,0,0),r.translate(-.625,0,0),a.translate(e,0,0),a.rotate(Math.PI,0,1,0),a.rotate(-Math.PI/2,1,0,0),i.rotate(Math.PI,0,1,0),i.translate(0,e,0),h.translate(0,-.625,0),h.rotate(Math.PI,1,0,0),this.stickers=[s,i,r,o,a,h],this.group=new Group(this.stickers)}makeStickers(t,e,s){const i=new Plane(e,e,t);s&&i.rotate(Math.PI/2,s.x,s.y,s.z),i.rotate(Math.PI/4,0,0,1),i.translate(-e/2,e/2,0);const r=[];for(let i=0;i<4;i++){const o=new Triangle(vector_Vector3.fromValues(-e/2,e/2,0),vector_Vector3.fromValues(0,e,0),vector_Vector3.fromValues(e/2,e/2,0),t);s&&o.rotate(Math.PI/2,s.x,s.y,s.z),o.rotate(Math.PI/2*i,0,0,1),o.rotate(Math.PI/4,0,0,1),r.push(o)}return[i,...r]}setColors(t){let{top:e,right:s,front:i,bottom:r,left:o,back:a}=t;this.setFaceColors(this.U,e),this.setFaceColors(this.R,s),this.setFaceColors(this.F,i),this.setFaceColors(this.D,r),this.setFaceColors(this.L,o),this.setFaceColors(this.B,a)}setFaceColors(t,e=[]){t.objects[0].faces[0].color=e[0]||R,t.objects[1].faces[0].color=e[1]||R,t.objects[2].faces[0].color=e[2]||R,t.objects[3].faces[0].color=e[4]||R,t.objects[4].faces[0].color=e[3]||R}}class TriangleLattice extends Geometry{constructor(t,e,s){const i=t/2,r=t*(Lt/2),o=t/e,a=r/e,h=r/3;let n=[],l=[],c=0;for(let t=0;t<=e;t++)for(let r=0,u=e-t;r<=u;r++){const e=o*r+t*o/2+-i,d=a*t+-h;n.push(vector_Vector3.fromValues(e,d,0)),t>0&&(r>0&&l.push(new Face([c,c-1,c-u-2],null,s)),l.push(new Face([c,c-u-2,c-u-1],null,s))),c++}l.forEach((t=>t.calculateCentroid(n))),super(n,l)}}const Bt=60*Math.PI/180;class PyraminxNet{constructor(t,e=.925){this.size=t;const s=e*(Lt/2)/1.5,i=.1*s,r=new TriangleLattice(e,t,f),o=new TriangleLattice(e,t,g),a=new TriangleLattice(e,t,v),h=new TriangleLattice(e,t,m);this.L=a,this.R=o,this.U=r,this.B=h,o.rotate(-Bt,0,0,1),o.translate(0,s+i,0),o.rotate(2*Bt,0,0,1),r.rotate(Bt,0,0,1),r.translate(0,s+i,0),r.rotate(-2*Bt,0,0,1),h.rotate(3*Bt,0,0,1),h.translate(0,s+i,0),h.rotate(-2*Bt,0,0,1),this.faces={top:this.U,right:this.R,left:this.L,back:this.B},this.group=new Group([r,o,a,h])}setColors(t){let{left:e,right:s,top:i,back:r}=t;this.setFaceColors(this.L,e),this.setFaceColors(this.R,s),this.setFaceColors(this.U,i),this.setFaceColors(this.B,r)}setFaceColors(t,e){t.faces.forEach(((t,s)=>{e&&e[s]?t.color=e[s]:t.color=R}))}}const It=Math.acos(1/3),Nt=120*Math.PI/180,_t=Math.sqrt(24);class Pyraminx{constructor(t,e=1.75){this.size=t;const s=e/_t,i=new TriangleLattice(e,t,f),r=new TriangleLattice(e,t,g),o=new TriangleLattice(e,t,v),a=new TriangleLattice(e,t,m);this.L=o,this.R=r,this.U=i,this.B=a,i.rotate(Nt,0,0,1),i.rotate(It,1,0,0),i.translate(0,0,s),r.rotate(It,1,0,0),r.translate(0,0,s),o.rotate(-Nt,0,0,1),o.rotate(It,1,0,0),o.translate(0,0,s),a.rotate(Math.PI,0,1,0),a.translate(0,0,s),this.faces={top:this.U,right:this.R,left:this.L,back:this.B},this.group=new Group([i,o,r,a])}setColors(t){let{left:e,right:s,top:i,back:r}=t;this.setFaceColors(this.L,e),this.setFaceColors(this.R,s),this.setFaceColors(this.U,i),this.setFaceColors(this.B,r)}setFaceColors(t,e){t.faces.forEach(((t,s)=>{e&&e[s]?t.color=e[s]:t.color=R}))}}class DividedPentagon extends Geometry{constructor(t,e=2,s=1.6,i=.4){const r=function(t){return t/(2*Math.sin(Math.PI/5))}(s),o=function(t){const e=t*t,s=71*Math.PI/180,i=2*e-2*e*Math.cos(s);return 2*Math.sqrt(Math.abs(e-i))}(i),a=function(t,e,s,i){let r=[];for(let o=0;o<t;o++){const t=e+s*o;r=[...r,...Dt(o,t,i)]}return r}(e,r-o*(e-1),o,i);super(a,function(t,e,s){let i=[];const r=new Face([0,1,2,3,4],s,e);i.push(r);let o=5,a=5;for(let r=1;r<t;r++){const t=5+10*r;o+=t;const h=zt(r),n=Ut(r-1),l=Ut(r);for(;a<o;){const r=a-(n[n.length-1]+1);if(r%(t/5)==0){a++;continue}const o=(r+1)%(t/5)==0;let c=a,u=l[(r+1)%l.length],d=o?u+1:h.shift(),f=o?h.shift():n[(n.indexOf(d)-1+n.length)%n.length];a++,i.push(new Face([c,u,d,f],s,e))}}return i}(e,t,a))}}function zt(t){if(t<1)return[];let e=[];const s=5+10*(t-1);let i=5*(t-1)*(t-1);for(let t=0;t<s;t++)e.push(t+i),t%(s/5)==0&&e.push(t+i);return e.push(e.shift()),e.push(e.shift()),e}function Ut(t){let e=5*t*t,s=[];for(let i=0,r=5+10*t;i<r;i++)s.push(i+e);return s}function At(t,e,s,i){if(0===s)return[vector_Vector3.fromValues(t.x,t.y,0),vector_Vector3.fromValues(e.x,e.y,0)];const r=function(t,e){return Math.sqrt(Math.pow(e.y-t.y,2)+Math.pow(e.x-t.x,2))}(t,e);let o=[];for(let a=s;a>0;a--){let s=vector_Vector3.fromValues(t.x+(e.x-t.x)/r*i*a,t.y+(e.y-t.y)/r*i*a,0);o.unshift(s);let h=vector_Vector3.fromValues(e.x+(t.x-e.x)/r*i*a,e.y+(t.y-e.y)/r*i*a,0);o.push(h)}return o.unshift(vector_Vector3.fromValues(t.x,t.y,0)),o.push(vector_Vector3.fromValues(e.x,e.y,0)),o}function Dt(t,e,s){let i=[];for(let r=0;r<5;r++){const o=Ct(e,r*(2*Math.PI)/5-Math.PI/10);if(i.length>0){const e=i[i.length-1],r=At(Vector2.fromValues(e.x,e.y),o,t,s);r.shift(),i=i.concat(r)}else i.push(vector_Vector3.fromValues(o.x,o.y,0))}const r=i[0],o=i[i.length-1],a=At(Vector2.fromValues(o.x,o.y),Vector2.fromValues(r.x,r.y),t,s);return a.pop(),a.shift(),i=i.concat(a),i}const Gt=36*Math.PI/180,Ot=72*Math.PI/180,Wt={2:.3,3:.17,4:.121};class MegaminxNet{constructor(t){this.layers=t;const e=.75,s=function(t,e){return Wt[e]||t/(1.9*e)}(length,t);this.U=new DividedPentagon(p,t,e,s),this.F=new DividedPentagon(m,t,e,s),this.R=new DividedPentagon(v,t,e,s),this.L=new DividedPentagon(g,t,e,s),this.dl=new DividedPentagon(S,t,e,s),this.dr=new DividedPentagon(C,t,e,s),this.BL=new DividedPentagon(w,t,e,s),this.BR=new DividedPentagon(f,t,e,s),this.d=new DividedPentagon(y,t,e,s),this.bl=new DividedPentagon(E,t,e,s),this.br=new DividedPentagon(k,t,e,s),this.b=new DividedPentagon(b,t,e,s);const i=2*function(t){return t/(2*Math.tan(Math.PI/5))}(e);this.U.translate(0,i,0),this.U.rotate(5*Gt,0,0,1),this.R.rotate(-Ot,0,0,1),this.R.translate(0,i,0),this.R.rotate(5*Gt,0,0,1),this.L.rotate(Ot,0,0,1),this.L.translate(0,i,0),this.L.rotate(-5*Gt,0,0,1),this.dl.rotate(2*Ot,0,0,1),this.dl.translate(0,i,0),this.dl.rotate(-5*Gt,0,0,1),this.dr.rotate(-2*Ot,0,0,1),this.dr.translate(0,i,0),this.dr.rotate(-5*Gt,0,0,1),this.b.rotate(Math.PI,0,0,1),this.b.rotate(-2*Gt,0,0,1),this.d.rotate(3*Gt,0,0,1),this.d.translate(0,i,0),this.d.rotate(5*Gt,0,0,1),this.br.rotate(Gt,0,0,1),this.br.translate(0,i,0),this.br.rotate(5*Gt,0,0,1),this.BR.rotate(-Gt,0,0,1),this.BR.translate(0,i,0),this.BR.rotate(-5*Gt,0,0,1),this.BL.rotate(-3*Gt,0,0,1),this.BL.translate(0,i,0),this.BL.rotate(5*Gt,0,0,1),this.bl.rotate(5*Gt,0,0,1),this.bl.translate(0,i,0),this.bl.rotate(-5*Gt,0,0,1);let r=new Matrix4;r.rotate(-Ot,0,0,1),r.translate(0,2*i,0),r.rotate(2*Ot,0,0,1),r.translate(0,-i,0),[this.d,this.bl,this.BL,this.BR,this.br,this.b].forEach((t=>{Matrix4.multiply(t.matrix,r,t.matrix)})),this.faces={U:this.U,F:this.F,R:this.R,dr:this.dr,dl:this.dl,L:this.L,d:this.d,br:this.br,BR:this.BR,BL:this.BL,bl:this.bl,b:this.b},this.group=new Group([this.U,this.F,this.L,this.dr,this.dl,this.R,this.d,this.bl,this.BL,this.BR,this.br,this.b]),this.group.scale(.33,.33,.33),this.group.translate(-1.3125,0,0)}setColors(t){let{U:e,R:s,F:i,d:r,L:o,b:a,dr:h,dl:n,br:l,BR:c,BL:u,bl:d}=t;this.setFaceColors(this.U,e),this.setFaceColors(this.R,s),this.setFaceColors(this.F,i),this.setFaceColors(this.d,r),this.setFaceColors(this.L,o),this.setFaceColors(this.b,a),this.setFaceColors(this.dr,h),this.setFaceColors(this.dl,n),this.setFaceColors(this.BR,c),this.setFaceColors(this.BL,u),this.setFaceColors(this.bl,d),this.setFaceColors(this.br,l)}oldSetColors(t){const e=this.layers,s=5*e*e-5*e+1;let[i,r,o,a,h,n,l,c,u,d,f,m]=function(t,e){const s=Math.ceil(t.length/e);return new Array(s).fill(null).map(((s,i)=>t.slice(i*e,(i+1)*e)))}(t,s);this.setFaceColors(this.U,i),this.setFaceColors(this.R,r),this.setFaceColors(this.F,o),this.setFaceColors(this.d,l),this.setFaceColors(this.L,n),this.setFaceColors(this.b,m),this.setFaceColors(this.dr,a),this.setFaceColors(this.dl,h),this.setFaceColors(this.br,c),this.setFaceColors(this.BR,u),this.setFaceColors(this.BL,d),this.setFaceColors(this.bl,f)}setFaceColors(t,e){t.faces.forEach(((t,s)=>{e&&e[s]?t.color=e[s]:t.color=R}))}}const jt={2:.3,3:.17,4:.121};class Megaminx{constructor(t=2){this.layers=t;const e=.75,s=Rt(e),i=function(t,e){return jt[e]||t/(1.9*e)}(e,t);this.U=new DividedPentagon(p,t,e,i),this.F=new DividedPentagon(m,t,e,i),this.R=new DividedPentagon(v,t,e,i),this.dr=new DividedPentagon(C,t,e,i),this.dl=new DividedPentagon(S,t,e,i),this.L=new DividedPentagon(g,t,e,i),this.d=new DividedPentagon(y,t,e,i),this.br=new DividedPentagon(k,t,e,i),this.BR=new DividedPentagon(f,t,e,i),this.BL=new DividedPentagon(w,t,e,i),this.bl=new DividedPentagon(E,t,e,i),this.b=new DividedPentagon(b,t,e,i),this.F.translate(0,0,s),this.b.rotate(Math.PI,0,0,1),this.b.rotate(Math.PI,0,1,0),this.b.translate(0,0,s),this.U.rotate(Math.PI,0,0,1),this.U.rotate((180-116.57)*Math.PI/180,1,0,0),this.U.translate(0,0,s),this.L.rotate(72*Math.PI/180,0,0,1),this.L.rotate(Math.PI,0,0,1),this.L.rotate((180-116.57)*Math.PI/180,1,0,0),this.L.translate(0,0,s),this.R.rotate(72*Math.PI/180,0,0,1),this.R.rotate(Math.PI/5,0,0,1),this.R.rotate((180-116.57)*Math.PI/180,1,0,0),this.R.translate(0,0,s),this.dr.rotate(72*Math.PI/180,0,0,1),this.dr.rotate(-Math.PI/5,0,0,1),this.dr.rotate((180-116.57)*Math.PI/180,1,0,0),this.dr.translate(0,0,s),this.dl.rotate(72*Math.PI/180,0,0,1),this.dl.rotate(-3*Math.PI/5,0,0,1),this.dl.rotate((180-116.57)*Math.PI/180,1,0,0),this.dl.translate(0,0,s),this.BL.rotate(Math.PI/5,0,0,1),this.BL.rotate(-116.57*Math.PI/180,1,0,0),this.BL.translate(0,0,s),this.BR.rotate(-Math.PI/5,0,0,1),this.BR.rotate(-116.57*Math.PI/180,1,0,0),this.BR.translate(0,0,s),this.bl.rotate(3*Math.PI/5,0,0,1),this.bl.rotate(-116.57*Math.PI/180,1,0,0),this.bl.translate(0,0,s),this.d.rotate(5*Math.PI/5,0,0,1),this.d.rotate(-116.57*Math.PI/180,1,0,0),this.d.translate(0,0,s),this.br.rotate(7*Math.PI/5,0,0,1),this.br.rotate(-116.57*Math.PI/180,1,0,0),this.br.translate(0,0,s),this.stickers=[this.U,this.F,this.R,this.dr,this.dl,this.L,this.d,this.br,this.BR,this.BL,this.bl,this.b],this.faces={U:this.U,F:this.F,R:this.R,dr:this.dr,dl:this.dl,L:this.L,d:this.d,br:this.br,BR:this.BR,BL:this.BL,bl:this.bl,b:this.b},this.group=new Group(this.stickers)}setColors(t){let{U:e,R:s,F:i,d:r,L:o,b:a,dr:h,dl:n,br:l,BR:c,BL:u,bl:d}=t;this.setFaceColors(this.U,e),this.setFaceColors(this.R,s),this.setFaceColors(this.F,i),this.setFaceColors(this.d,r),this.setFaceColors(this.L,o),this.setFaceColors(this.b,a),this.setFaceColors(this.dr,h),this.setFaceColors(this.dl,n),this.setFaceColors(this.BR,c),this.setFaceColors(this.BL,u),this.setFaceColors(this.bl,d),this.setFaceColors(this.br,l)}setFaceColors(t,e){t.faces.forEach(((t,s)=>{e&&e[s]?t.color=e[s]:t.color=R}))}}function $t(t,e,s){const i=t/2,r=t/e,o=r/2;let a=[];for(let h=0;h<e;h++){let n=-(-i+o+r*h);a=a.concat(Xt(t,e,s,n))}return a}function Xt(t,e,s,i=0){const r=t/2,o=t/e,a=o/2;let h=[];for(let t=0;t<e;t++){let e=-r+a+o*t,n=[vector_Vector3.fromValues(-a+e,a+i,0),vector_Vector3.fromValues(a+e,a+i,0),vector_Vector3.fromValues(a+e,-a+i,0),vector_Vector3.fromValues(-a+e,-a+i,0)],l=[new Face([0,1,2,3],n,s)];h.push(new Geometry(n,l))}return h}class RubiksCubeTopLayer{constructor(t,e=Math.PI/4){this.size=t,this.cubeWidth=1.45,this.halfCubeWidth=this.cubeWidth/2,this.stickerWidth=this.cubeWidth/t,this.halfStickerWidth=this.stickerWidth/2,this.cubeWidth=this.stickerWidth*t,this.U=new Group($t(this.cubeWidth,this.size,f)),this.R=new Group(Xt(this.cubeWidth,this.size,m)),this.F=new Group(Xt(this.cubeWidth,this.size,v)),this.B=new Group(Xt(this.cubeWidth,this.size,g)),this.L=new Group(Xt(this.cubeWidth,this.size,b));const s=this.halfCubeWidth+this.halfStickerWidth;this.B.translate(0,s,0),this.B.rotate(Math.PI,0,0,1),this.F.translate(0,-s,0),this.R.translate(s,0,0),this.R.rotate(Math.PI/2,0,0,1),this.L.translate(-s,0,0),this.L.rotate(-Math.PI/2,0,0,1),this.rotateBorder(this.F.objects,e),this.rotateBorder(this.R.objects,e),this.rotateBorder(this.B.objects,e),this.rotateBorder(this.L.objects,e),this.stickers=[this.U,this.R,this.F,this.B,this.L],this.group=new Group(this.stickers),this.faces={U:this.U,R:this.R,F:this.F,L:this.L,B:this.B}}setFaceColors(t,e){t.objects.forEach(((t,s)=>{e&&e[s]?t.faces[0].color=e[s]:t.faces[0].color=R}))}setColors(t){let{U:e,R:s,F:i,L:r,B:o}=t;this.setFaceColors(this.U,e),this.setFaceColors(this.R,s),this.setFaceColors(this.F,i),this.setFaceColors(this.L,r),this.setFaceColors(this.B,o)}rotateBorder(t,e){t.forEach((t=>{t.vertices=t.vertices.map((t=>t.rotateX(vector_Vector3.fromValues(0,this.halfStickerWidth,0),e))),t.centroid=Ft(t.vertices)}))}}class RubiksCubeNet{constructor(t){this.size=t;const e=$t(1,t,f),s=$t(1,t,m),i=$t(1,t,v),r=$t(1,t,p),o=$t(1,t,b),a=$t(1,t,g);this.U=new Group(e),this.U.translate(0,1,0),this.R=new Group(s),this.R.translate(1,0,0),this.F=new Group(i),this.D=new Group(r),this.D.translate(0,-1,0),this.L=new Group(o),this.L.translate(-1,0,0),this.B=new Group(a),this.B.translate(2,0,0),this.stickers=[this.U,this.R,this.F,this.D,this.L,this.B],this.faces={U:this.U,R:this.R,F:this.F,D:this.D,L:this.L,B:this.B},this.group=new Group(this.stickers),this.group.translate(-1/4,0,0),this.group.scale(.5,.5,.5)}setFaceColors(t,e){t.objects.forEach(((t,s)=>{e&&e[s]?t.faces[0].color=e[s]:t.faces[0].color=R}))}setColors(t){let{U:e,R:s,F:i,D:r,L:o,B:a}=t;this.setFaceColors(this.U,e),this.setFaceColors(this.R,s),this.setFaceColors(this.F,i),this.setFaceColors(this.D,r),this.setFaceColors(this.L,o),this.setFaceColors(this.B,a)}}class RubiksCube{constructor(t){this.size=t;const e=1.25,s=.625;this.U=new Group($t(e,t,f)),this.R=new Group($t(e,t,m)),this.F=new Group($t(e,t,v)),this.D=new Group($t(e,t,p)),this.L=new Group($t(e,t,b)),this.B=new Group($t(e,t,g)),this.U.rotate(-Math.PI/2,0,1,0),this.U.rotate(-Math.PI/2,1,0,0),this.U.translate(0,0,s),this.R.translate(0,0,s),this.F.rotate(-Math.PI/2,0,1,0),this.F.translate(0,0,s),this.D.rotate(-Math.PI/2,0,1,0),this.D.rotate(Math.PI/2,1,0,0),this.D.translate(0,0,s),this.L.rotate(-Math.PI,0,1,0),this.L.translate(0,0,s),this.B.rotate(Math.PI/2,0,1,0),this.B.translate(0,0,s),this.stickers=[this.U,this.R,this.F,this.D,this.L,this.B],this.faces={U:this.U,R:this.R,F:this.F,D:this.D,L:this.L,B:this.B},this.group=new Group(this.stickers)}setFaceColors(t,e){t.objects.forEach(((t,s)=>{e&&e[s]?t.faces[0].color=e[s]:t.faces[0].color=R}))}setColors(t){let{U:e,R:s,F:i,D:r,L:o,B:a}=t;this.setFaceColors(this.U,e),this.setFaceColors(this.R,s),this.setFaceColors(this.F,i),this.setFaceColors(this.D,r),this.setFaceColors(this.L,o),this.setFaceColors(this.B,a)}}class Arrow extends Object3D{constructor(t,e){super(),this.p1=t,this.p2=e,this.centroid=Ft([t,e])}}function qt(t,e){let s=t.clone();return e.forEach(((t,e)=>{s.transformMat4(t)})),s}class PolygonRenderer{constructor(){this.polygons=[],this.arrows=[]}render(t,e){this.polygons=[],t.objects.forEach((t=>{this.renderObject3D(t,e,[])})),this.onBeforeRender(),this.renderPolygons(),this.renderArrows(),this.onComplete()}renderPolygons(){this.polygons.sort(((t,e)=>t.centroid.z-e.centroid.z)),this.polygons.forEach((t=>this.drawPolygon(t)))}renderArrows(){this.arrows.forEach((({p1:t,p2:e,uid:s})=>{this.drawArrow(t,e,s)}))}renderObject3D(t,e,s){if(t instanceof Geometry)this.renderGeometry(t,e,s);else if(t instanceof Arrow)this.renderArrow(t,e,s);else if(t instanceof Group){let i=t;i.objects.forEach((t=>{this.renderObject3D(t,e,[i.matrix,...s])}))}}renderGeometry(t,e,s){t.faces.forEach((i=>{let r=[];i.indices.map((e=>t.vertices[e])).forEach((i=>{let o=qt(i,[t.matrix,...s,e.matrix]);o.multiply(1,-1,1),r.push(o)})),this.addPolygon(r,i,t,s)}))}renderArrow(t,e,s){let i=[t.matrix,...s,e.matrix],r=qt(t.p1,i),o=qt(t.p2,i);this.arrows.push({p1:r,p2:o,uid:t.uid})}addPolygon(t,e,s,i){this.polygons.push({points:t,face:e,object:s,centroid:qt(e.centroid,[s.matrix,...i])})}sortObjects(t,e,s){let i=[...t];return i.sort(((t,e)=>{let i=[t.matrix,...s],r=[e.matrix,...s],o=qt(t.centroid,i),a=qt(e.centroid,r);return o.z-a.z})),i}}function Ht(t,e,s,i){const r=function(t){return t.reduce(((t,e)=>`${t?t+" ":""}${e.x}, ${e.y}`),"")}(e),o=s?s.value:"black",a=s&&s.stroke||"#000000";t.setAttributeNS(null,"points",r),t.setAttributeNS(null,"fill",o),i&&(t.setAttributeNS(null,"stroke",a),t.setAttributeNS(null,"stroke-width",i)),t.setAttributeNS(null,"stroke-linejoin","round")}class HtmlSvgRenderer extends PolygonRenderer{constructor(t,e,s,i,r,o,a){super(),this.strokeWidth="0.035",this.arrowStrokeWidth="0.03",this.polygons=[],this.lines=[],this.uidToPolygon={},this.uidToLine={},this.arrowColor=a||R,this.domElement=document.createElement("div"),this.domElement.className="svg-renderer",this.svgElement=function(t,e,s,i,r,o){const a=document.createElementNS("http://www.w3.org/2000/svg","svg");return a.setAttributeNS(null,"width",t.toString()),a.setAttributeNS(null,"height",e.toString()),a.setAttributeNS(null,"viewBox",`${s} ${i} ${r} ${o}`),a.setAttributeNS(null,"id","sr-visualizer"),a}(t,e,s,i,r,o);const h=function(t){const e=document.createElementNS("http://www.w3.org/2000/svg","defs"),s=document.createElementNS("http://www.w3.org/2000/svg","marker");s.setAttributeNS(null,"id","arrowhead"),s.setAttributeNS(null,"markerWidth","4"),s.setAttributeNS(null,"markerHeight","3.5"),s.setAttributeNS(null,"refX","3"),s.setAttributeNS(null,"refY","1.75"),s.setAttributeNS(null,"orient","auto");const i=document.createElementNS("http://www.w3.org/2000/svg","polygon");return i.setAttributeNS(null,"points","0 0, 4 1.75, 0 3.5"),i.setAttributeNS(null,"fill",t.value),e.appendChild(s),s.appendChild(i),e}(this.arrowColor);this.svgElement.appendChild(h),this.domElement.appendChild(this.svgElement)}onBeforeRender(){}drawPolygon({points:t,face:e,object:s}){if(this.uidToPolygon[e.uid]){Ht(this.uidToPolygon[e.uid],t,e.color||s.color,this.strokeWidth)}else this.uidToPolygon[e.uid]=function(t,e,s){const i=document.createElementNS("http://www.w3.org/2000/svg","polygon");return Ht(i,t,e,s),i}(t,e.color||s.color,this.strokeWidth);this.svgElement.appendChild(this.uidToPolygon[e.uid])}drawArrow(t,e,s){let i;this.uidToLine[s]?(i=this.uidToLine[s],i.setAttributeNS(null,"x1",t[0].toString()),i.setAttributeNS(null,"y1",(-t[1]).toString()),i.setAttributeNS(null,"x2",e[0].toString()),i.setAttributeNS(null,"y2",(-e[1]).toString())):(i=function(t,e,s,i){const r=document.createElementNS("http://www.w3.org/2000/svg","line");let o=s?s.value:R.value;return r.setAttributeNS(null,"x1",t.x.toString()),r.setAttributeNS(null,"y1",(-t.y).toString()),r.setAttributeNS(null,"x2",e.x.toString()),r.setAttributeNS(null,"y2",(-e.y).toString()),r.setAttributeNS(null,"stroke",o),r.setAttributeNS(null,"marker-end","url(#arrowhead)"),i&&r.setAttributeNS(null,"stroke-width",i),r}(t,e,this.arrowColor,this.arrowStrokeWidth),this.uidToLine[s]=i),this.svgElement.appendChild(this.uidToLine[s])}onComplete(){}}class HtmlCanvasRenderer extends PolygonRenderer{constructor(t,e,s=5,i=R){super(),this.width=t,this.height=e,this.lineWidth=s,this.arrowColor=i,this.domElement=document.createElement("div"),this.domElement.className="canvas-renderer",this.canvasElement=document.createElement("canvas"),this.domElement.appendChild(this.canvasElement),this.canvasElement.width=t,this.canvasElement.height=e,this.ctx=this.canvasElement.getContext("2d")}convertRange(t,e){return(t- -.9)/1.8*e}onBeforeRender(){this.ctx.clearRect(0,0,this.width,this.height)}drawPolygon(t){var e,s;this.ctx.lineWidth=this.lineWidth,this.ctx.lineJoin="round",this.ctx.fillStyle=(null===(s=null===(e=null==t?void 0:t.face)||void 0===e?void 0:e.color)||void 0===s?void 0:s.value)||"#000000",this.ctx.strokeStyle="#000000",this.ctx.moveTo(this.convertRange(t.points[0].x,this.width),this.convertRange(t.points[0].y,this.height)),this.ctx.beginPath();for(let e=0;e<=t.points.length;e++){let s=t.points[(e+1)%t.points.length];this.ctx.lineTo(this.convertRange(s.x,this.width),this.convertRange(s.y,this.height))}this.ctx.closePath(),this.ctx.fill(),this.ctx.stroke()}drawArrow(t,e,s){const i=this.convertRange(e.x,this.width),r=this.convertRange(-e.y,this.height),o=this.convertRange(t.x,this.width),a=this.convertRange(-t.y,this.height),h=i-o,n=r-a,l=Math.atan2(n,h);this.ctx.strokeStyle=this.arrowColor.value,this.ctx.beginPath(),this.ctx.moveTo(o,a),this.ctx.lineTo(i,r),this.ctx.lineTo(i-20*Math.cos(l-Math.PI/6),r-20*Math.sin(l-Math.PI/6)),this.ctx.moveTo(i,r),this.ctx.lineTo(i-20*Math.cos(l+Math.PI/6),r-20*Math.sin(l+Math.PI/6)),this.ctx.stroke()}setLineWidth(t){this.lineWidth=t}onComplete(){}}class Camera{constructor(){this.matrix=Matrix4.perspective(Math.PI/2,1,.1,1e3),this.matrix.translate(0,0,-5),this.matrix.scale(4,4,1)}}class Scene{constructor(){this.objects=[]}add(t){this.objects.push(t)}clear(){this.objects=[]}}var Yt;!function(t){t.CUBE="cube",t.CUBE_NET="cube-net",t.CUBE_TOP="cube-top",t.MEGAMINX="megaminx",t.MEGAMINX_NET="megaminx-net",t.MEGAMINX_TOP="megaminx-top",t.PYRAMINX="pyraminx",t.PYRAMINX_NET="pyraminx-net",t.SKEWB="skewb",t.SKEWB_NET="skewb-net",t.SQUARE1="square1",t.SQUARE1_NET="square1-net"}(Yt||(Yt={}));const Kt={size:3,scheme:{U:f,R:m,F:v,D:p,L:b,B:g},rotations:[{x:0,y:45,z:0},{x:34,y:0,z:0}]},Zt={size:2,scheme:{U:p,F:m,R:v,dr:C,dl:S,L:g,d:y,br:k,BR:f,BL:w,bl:E,b}},Qt={size:3,scheme:{left:v,right:g,top:f,back:m},rotations:[{x:0,y:0,z:60},{x:-60,y:0,z:0}]},Jt={scheme:{top:f,front:v,right:m,back:g,left:b,bottom:p},rotations:[{x:0,y:45,z:0},{x:34,y:0,z:0}]},te={scheme:q,rotations:[{x:0,y:0,z:-34},{x:-56,y:0,z:0}]};function ee(t){if(t.alg&&"string"!=typeof t.alg&&(console.warn(`Inavlid alg ${t.alg}. alg must be a string`),t.alg=""),t.case&&"string"!=typeof t.case&&(console.warn(`Inavlid case ${t.case}. case must be a string`),t.case=""),t.scheme&&("object"!=typeof t.scheme||Array.isArray(t.scheme)?(console.warn(`Invalid scheme ${t.scheme}. scheme must be an object`),t.scheme={}):Object.keys(t.scheme).forEach((e=>{const s=t.scheme[e];null!=s&&"object"==typeof s&&s.value||(console.warn(`Invalid scheme color ${s}. must be an type IColor`),t.scheme[e]=R)}))),t.mask&&("object"!=typeof t.mask||Array.isArray(t.mask)?(console.warn(`Invalid mask ${t.mask}. scheme must be an object`),t.mask={}):Object.keys(t.mask).forEach((e=>{const s=t.mask[e];if(Array.isArray(s)){for(let i=0;i<s.length;i++)if(!Number.isInteger(s[i])){console.warn(`Invalid mask value ${s[i]}. must be a number`),t.mask[e]=[];break}}else console.warn(`Invalid mask ${s}. must be an array`),t.mask[e]=[]}))),t.stickerColors&&("object"!=typeof t.stickerColors||Array.isArray(t.stickerColors)?(console.warn(`Invalid stickerColors ${t.stickerColors}. stickerColors must be an object`),t.stickerColors={}):Object.keys(t.stickerColors).forEach((e=>{const s=t.stickerColors[e];if(Array.isArray(s)){for(let i=0;i<s.length;i++)if(!se(s[i])){t.stickerColors[e]=[];break}}else console.warn(`Invalid colors ${s}. must be an array`),t.stickerColors[e]=[]}))),t.rotations)if(Array.isArray(t.rotations)){for(let e=0;e<t.rotations.length;e++)if(!ie(t.rotations[e])){t.rotations=[];break}}else console.warn(`invalid rotations ${t.rotations}, must be an array`),t.rotations=[];if(t.scale&&!Number.isFinite(t.scale)&&(console.warn(`invalid scale ${t.scale}, must be a finite number`),t.scale=1),t.translation&&!function(t){if("object"!=typeof t||Array.isArray(t))return console.warn(`invalid translation ${t}, must be an object`),!1;if(t.x&&!Number.isFinite(t.x))return console.warn(`invalid x translation ${t.x}, must be a number`),!1;if(t.y&&!Number.isFinite(t.y))return console.warn(`invalid y translation ${t.y}, must be a number`),!1;if(t.z&&!Number.isFinite(t.z))return console.warn(`invalid z translation ${t.z}, must be a number`),!1;return!0}(t.translation)&&(t.translation={x:0,y:0,z:0}),t.arrows)if(Array.isArray(t.arrows)){for(let e=0;e<t.arrows.length;e++)if(!re(t.arrows[e])){t.arrows=[];break}}else console.warn("invalid arrows, must be an array"),t.arrows=[]}function se(t){return"object"!=typeof t?(console.warn(`invalid color ${t}, must be type object`),!1):t.value&&"string"==typeof t.value?!t.stroke||"string"==typeof t.stroke||(console.warn(`invalid color stroke ${t.stroke}, must be type string`),!1):(console.warn(`invalid color value ${t.value}, must be type string`),!1)}function ie(t){return t&&"object"==typeof t?t.x&&!Number.isFinite(t.x)?(console.warn(`invalid x rotation ${t.x}, must be a number`),!1):t.y&&!Number.isFinite(t.y)?(console.warn(`invalid y rotation ${t.y}, must be a number`),!1):!(t.z&&!Number.isFinite(t.z))||(console.warn(`invalid z rotation ${t.z}, must be a number`),!1):(console.warn(`invalid rotation ${t}, must be an object`),!1)}function re(t){return"object"!=typeof t?(console.warn(`invalid arrow ${t}, must be an object`),!1):"object"!=typeof t.end||"object"!=typeof t.start?(console.warn(`invalid arrow ${t}, must have start and end`),!1):"string"==typeof t.start.face&&Number.isInteger(t.start.sticker)?!("string"!=typeof t.end.face||!Number.isInteger(t.end.sticker))||(console.warn(`invalid arrow end ${t.end}`),!1):(console.warn(`invalid arrow start ${t.start}`),!1)}const oe={2:.3,3:.17,4:.121};class MegaminxTop{constructor(){this.createFaces(),this.removeHiddenStickers()}createFaces(){const t=.75,e=function(t,e){return oe[e]||t/(1.9*e)}(t,2),s=Rt(t);this.U=new DividedPentagon(p,2,t,e),this.F=new DividedPentagon(m,2,t,e),this.R=new DividedPentagon(v,2,t,e),this.L=new DividedPentagon(g,2,t,e),this.BR=new DividedPentagon(f,2,t,e),this.BL=new DividedPentagon(w,2,t,e),this.F.translate(0,0,s),this.U.rotate(Math.PI,0,0,1),this.U.rotate((180-116.57)*Math.PI/180,1,0,0),this.U.translate(0,0,s),this.L.rotate(72*Math.PI/180,0,0,1),this.L.rotate(Math.PI,0,0,1),this.L.rotate((180-116.57)*Math.PI/180,1,0,0),this.L.translate(0,0,s),this.R.rotate(72*Math.PI/180,0,0,1),this.R.rotate(Math.PI/5,0,0,1),this.R.rotate((180-116.57)*Math.PI/180,1,0,0),this.R.translate(0,0,s),this.BL.rotate(Math.PI/5,0,0,1),this.BL.rotate(-116.57*Math.PI/180,1,0,0),this.BL.translate(0,0,s),this.BR.rotate(-Math.PI/5,0,0,1),this.BR.rotate(-116.57*Math.PI/180,1,0,0),this.BR.translate(0,0,s),this.faces={U:this.U,F:this.F,R:this.R,dr:this.BR,dl:this.BL,L:this.L},this.group=new Group([this.U,this.F,this.R,this.BR,this.BL,this.L]),this.group.rotate(kt(63),1,0,0)}setColors(t){let{U:e,R:s,F:i,L:r,BR:o,BL:a}=t;this.createFaces(),this.setFaceColors(this.U,e),this.setFaceColors(this.R,s),this.setFaceColors(this.F,i),this.setFaceColors(this.L,r),this.setFaceColors(this.BR,o),this.setFaceColors(this.BL,a),this.removeHiddenStickers()}setFaceColors(t,e){t.faces.forEach(((t,s)=>{e&&e[s]?t.color=e[s]:t.color=R}))}removeHiddenStickers(){this.F.faces=this.F.faces.slice(2,5),this.BL.faces=this.BL.faces.slice(8,11),this.L.faces=this.L.faces.slice(4,7),this.R.faces=[this.R.faces[1],this.R.faces[2],this.R.faces[10]],this.BR.faces=this.BR.faces.slice(6,9)}}const ae={[Yt.CUBE]:{},[Yt.CUBE_NET]:{},[Yt.CUBE_TOP]:{},[Yt.MEGAMINX]:{},[Yt.MEGAMINX_NET]:{},[Yt.MEGAMINX_TOP]:{},[Yt.PYRAMINX]:{},[Yt.PYRAMINX_NET]:{},[Yt.SKEWB]:{},[Yt.SKEWB_NET]:{},[Yt.SQUARE1]:{},[Yt.SQUARE1_NET]:{}};function he(t,e){switch(t){case Yt.CUBE:return function(t={}){ae[Yt.CUBE][t.size]||(ae[Yt.CUBE][t.size]=new RubiksCube(t.size));return ae[Yt.CUBE][t.size]}(e);case Yt.CUBE_NET:return function(t={}){ae[Yt.CUBE_NET][t.size]||(ae[Yt.CUBE_NET][t.size]=new RubiksCubeNet(t.size));return ae[Yt.CUBE_NET][t.size]}(e);case Yt.CUBE_TOP:return function(t={}){ae[Yt.CUBE_TOP][t.size]||(ae[Yt.CUBE_TOP][t.size]=new RubiksCubeTopLayer(t.size));return ae[Yt.CUBE_TOP][t.size]}(e);case Yt.MEGAMINX:return function(t={}){ae[Yt.MEGAMINX][t.size]||(ae[Yt.MEGAMINX][t.size]=new Megaminx(t.size));return ae[Yt.MEGAMINX][t.size]}(e);case Yt.MEGAMINX_NET:return function(t={}){ae[Yt.MEGAMINX_NET][t.size]||(ae[Yt.MEGAMINX_NET][t.size]=new MegaminxNet(t.size));return ae[Yt.MEGAMINX_NET][t.size]}(e);case Yt.MEGAMINX_TOP:return function(t={}){ae[Yt.MEGAMINX_TOP][2]||(ae[Yt.MEGAMINX_TOP][2]=new MegaminxTop);return ae[Yt.MEGAMINX_TOP][2]}(e);case Yt.PYRAMINX:return function(t={}){ae[Yt.PYRAMINX][t.size]||(ae[Yt.PYRAMINX][t.size]=new Pyraminx(t.size));return ae[Yt.PYRAMINX][t.size]}(e);case Yt.PYRAMINX_NET:return function(t={}){ae[Yt.PYRAMINX_NET][t.size]||(ae[Yt.PYRAMINX_NET][t.size]=new PyraminxNet(t.size));return ae[Yt.PYRAMINX_NET][t.size]}(e);case Yt.SKEWB:return function(t={}){ae[Yt.SKEWB][1]||(ae[Yt.SKEWB][1]=new Skewb);return ae[Yt.SKEWB][1]}(e);case Yt.SKEWB_NET:return function(t={}){ae[Yt.SKEWB_NET][1]||(ae[Yt.SKEWB_NET][1]=new SkewbNet);return ae[Yt.SKEWB_NET][1]}(e);case Yt.SQUARE1:return function(t={}){const e=ne(t);return new Square1(e.topLayer,e.bottomLayer,e.middleRotated,t.scheme)}(e);case Yt.SQUARE1_NET:return function(t={}){const e=ne(t);return new Square1Net(e.topLayer,e.bottomLayer,e.middleRotated,t.scheme)}(e)}}function ne(t){const e=new Square1Simualtor(t.scheme);return t.case?e.case(t.case):t.alg&&e.alg(t.alg),e}class Quaternion{constructor(t,e,s,i){this.a=t,this.b=e,this.c=s,this.d=i}static fromEuler(t,e,s){let i=Math.PI/360;t*=i,s*=i,e*=i;let r=Math.sin(t),o=Math.cos(t),a=Math.sin(e),h=Math.cos(e),n=Math.sin(s),l=Math.cos(s);return new Quaternion(r*h*l-o*a*n,o*a*l+r*h*n,o*h*n-r*a*l,o*h*l+r*a*n)}}function le(t){return t===Yt.SQUARE1||t===Yt.SQUARE1_NET}function ce(t,e){return function(t){return t===Yt.PYRAMINX||t===Yt.PYRAMINX_NET}(t)?3===e:!function(t){return t===Yt.MEGAMINX||t===Yt.MEGAMINX_NET||t===Yt.MEGAMINX_TOP}(t)||2===e}class Visualizer{constructor(t,e,s={}){this.type=e,this.camera=new Camera,this.scene=new Scene,this.group=new Group,this.scene.add(this.group),this.renderer=t,this.initPuzzleOptions(s),this.puzzleGeometry=he(this.type,this.options),this.simulator=function(t,e){switch(t){case Yt.CUBE:case Yt.CUBE_NET:case Yt.CUBE_TOP:return new RubiksCubeSimulator(e.size);case Yt.MEGAMINX:case Yt.MEGAMINX_NET:case Yt.MEGAMINX_TOP:return new MegaminxSimulator;case Yt.PYRAMINX:case Yt.PYRAMINX_NET:return new PyraminxSimulator;case Yt.SKEWB:case Yt.SKEWB_NET:return new SkewbSimulator;case Yt.SQUARE1:case Yt.SQUARE1_NET:return ne(e)}}(this.type,this.options),this.buildGroupMatrix(),this.applyColors(),this.addArrows(),this.group.addObject(this.puzzleGeometry.group),this.render()}applyColors(){const t=this.options.stickerColors&&!le(this.type),e=ce(this.type,this.options.size);if(t)this.puzzleGeometry.setColors(this.options.stickerColors);else if(e)this.applySimulatorColors();else{const t=this.puzzleGeometry.faces;Object.keys(t).forEach((e=>{const s=t[e],i=this.options.scheme[e];s instanceof Geometry?s.faces.forEach((t=>t.color=i)):s instanceof Group&&s.objects.forEach((t=>t.color=i))}))}}applySimulatorColors(){this.options.mask&&this.applyMask(this.options),(this.options.alg||this.options.case)&&this.applyAlgorithm();const t=function(t,e){return Object.keys(t).reduce(((s,i)=>(s[i]=t[i].map((t=>e[t]||F)),s)),{})}(this.simulator.getValues(),this.options.scheme);this.puzzleGeometry.setColors(t)}applyAlgorithm(){le(this.type)||(this.options.case?this.simulator.case(this.options.case):this.options.alg&&this.simulator.alg(this.options.alg))}applyMask(t){Object.keys(t.mask).forEach((e=>{t.mask[e].forEach((t=>this.simulator.setValue(e,t,"mask")))}))}buildGroupMatrix(){if(this.group.matrix=new Matrix4,this.options.rotations&&this.options.rotations.forEach((t=>{const{x:e=0,y:s=0,z:i=0}=t;let r=Matrix4.fromQuaternion(Quaternion.fromEuler(e,s,i));Matrix4.multiply(this.group.matrix,r,this.group.matrix)})),this.options.scale){let t=this.options.scale;this.group.matrix.scale(t,t,t)}if(this.options.translation){const{x:t=0,y:e=0,z:s=0}=this.options.translation;let i=Matrix4.fromTranslation(t,e,s);Matrix4.multiply(this.group.matrix,i,this.group.matrix)}}addArrows(){this.options.arrows&&this.options.arrows.forEach((t=>{try{this.scene.add(function(t,e,s){var i,r,o,a,h,n,l,c;let u=e.faces[t.start.face],d=e.faces[t.end.face];if(!u||!d)throw new Error(`Invalid arrow definition ${JSON.stringify(t)}`);let f,m,v=[u.matrix,e.group.matrix,s.matrix],p=[d.matrix,e.group.matrix,s.matrix];if(u instanceof Geometry&&d instanceof Geometry?(f=null===(i=u.faces[t.start.sticker])||void 0===i?void 0:i.centroid,m=null===(r=d.faces[t.end.sticker])||void 0===r?void 0:r.centroid):(e instanceof Square1?(f=null===(o=u.objects[t.start.sticker])||void 0===o?void 0:o.faces[0].centroid,m=null===(a=d.objects[t.end.sticker])||void 0===a?void 0:a.faces[0].centroid):(f=null===(h=u.objects[t.start.sticker])||void 0===h?void 0:h.centroid,m=null===(n=d.objects[t.end.sticker])||void 0===n?void 0:n.centroid),v.unshift(null===(l=u.objects[t.start.sticker])||void 0===l?void 0:l.matrix),p.unshift(null===(c=d.objects[t.end.sticker])||void 0===c?void 0:c.matrix)),!f||!m)throw new Error(`Invalid arrow definition ${JSON.stringify(t)}`);let b=qt(f,v),g=qt(m,p);return new Arrow(b,g)}(t,this.puzzleGeometry,this.group))}catch(e){console.error(e),console.warn(`Invalid arrow ${JSON.stringify(t)}`)}}))}initPuzzleOptions(t){this.options=Object.assign(Object.assign({},function(t){switch(t){case Yt.CUBE:return Kt;case Yt.CUBE_NET:case Yt.CUBE_TOP:return Object.assign(Object.assign({},Kt),{rotations:null});case Yt.MEGAMINX:case Yt.MEGAMINX_NET:case Yt.MEGAMINX_TOP:return Zt;case Yt.PYRAMINX:return Qt;case Yt.PYRAMINX_NET:return Object.assign(Object.assign({},Qt),{rotations:null});case Yt.SKEWB:return Jt;case Yt.SKEWB_NET:return Object.assign(Object.assign({},Jt),{rotations:null});case Yt.SQUARE1:return te;case Yt.SQUARE1_NET:return Object.assign(Object.assign({},te),{rotations:null});default:throw new Error(`Could not get default options for puzzle ${t}`)}}(this.type)),t),ee(this.options)}applyOptionsToPuzzle(){this.simulator.reset(),this.buildGroupMatrix(),this.applyColors(),this.addArrows()}setPuzzleOptions(t){this.initPuzzleOptions(t),le(this.type)&&(this.puzzleGeometry=he(this.type,this.options),this.group.setObjects([this.puzzleGeometry.group])),this.applyOptionsToPuzzle()}render(){this.renderer.render(this.scene,this.camera)}}const ue={width:500,height:500,minx:-.9,miny:-.9,svgWidth:1.8,svgHeight:1.8,strokeWidth:.02,arrowColor:y,arrowStrokeWidth:.03};function de(t,e,s={}){return new SvgVisualizer(t,e,s)}class SvgVisualizer extends Visualizer{constructor(t,e,s={}){if(s=Object.assign(Object.assign({},ue),s),"string"==typeof t&&null===(t=document.querySelector(t)))throw new Error(`Could not find visuzlier element by query selector: ${t}`);const i=new HtmlSvgRenderer(s.width,s.height,s.minx,s.miny,s.svgWidth,s.svgHeight,s.arrowColor);i.strokeWidth=""+s.strokeWidth,t.appendChild(i.domElement),super(i,e,s.puzzle),this.svgOptions=s}setStrokeWidth(t){this.svgOptions.strokeWidth=t,this.renderer.strokeWidth=""+this.svgOptions.strokeWidth,this.render()}setSvgOptions(t){this.svgOptions=Object.assign(Object.assign({},ue),t),function(t){Number.isInteger(t.width)||(console.warn(`invalid svg width ${t.width}. Must be a whole number`),t.width=ue.width);Number.isInteger(t.height)||(console.warn(`invalid svg height ${t.height}. Must be a whole number`),t.width=ue.height);Number.isFinite(t.minx)||(console.warn(`invalid svg minx ${t.minx}`),t.minx=ue.minx);Number.isFinite(t.miny)||(console.warn(`invalid svg miny ${t.miny}`),t.minx=ue.miny);Number.isFinite(t.svgWidth)||(console.warn(`invalid svgWidth ${t.svgWidth}`),t.minx=ue.svgWidth);Number.isFinite(t.svgHeight)||(console.warn(`invalid svgHeight ${t.svgHeight}`),t.minx=ue.svgHeight);Number.isFinite(t.strokeWidth)||(console.warn(`invalid strokeWidth ${t.strokeWidth}`),t.minx=ue.strokeWidth);Number.isFinite(t.arrowStrokeWidth)||(console.warn(`invalid arrowStrokeWidth ${t.arrowStrokeWidth}`),t.minx=ue.arrowStrokeWidth);t.arrowColor&&!se(t.arrowColor)&&(t.arrowColor=R)}(this.svgOptions);const e=this.renderer,s=e.svgElement;e.strokeWidth=""+this.svgOptions.strokeWidth,e.arrowStrokeWidth=""+this.svgOptions.arrowStrokeWidth,s.setAttributeNS(null,"width",this.svgOptions.width.toString()),s.setAttributeNS(null,"height",this.svgOptions.width.toString()),s.setAttributeNS(null,"viewBox",`${this.svgOptions.minx} ${this.svgOptions.miny} ${this.svgOptions.svgWidth} ${this.svgOptions.svgHeight}`),this.render()}}const fe={width:500,height:500,minx:-.9,miny:-.9,svgWidth:1.8,svgHeight:1.8,strokeWidth:.02,arrowColor:y,arrowStrokeWidth:.03};function me(t,e,s={}){if("string"==typeof t&&null===(t=document.querySelector(t)))throw new Error(`Could not find visuzlier element by query selector: ${t}`);let i=document.createElement("div");s=Object.assign(Object.assign({},fe),s),de(i,e,s),setTimeout((()=>{let e=i.querySelector("svg"),r=document.createElement("img");t.appendChild(r);let o=document.createElement("canvas"),a=o.getContext("2d"),h=new Image;h.width=o.width=r.width=s.width,h.height=o.height=r.height=s.height,h.onload=function(){a.drawImage(h,0,0,h.width,h.height),r.src=o.toDataURL()};var n=(new XMLSerializer).serializeToString(e);h.src=`data:image/svg+xml,${encodeURIComponent(n)}`}))}const ve={width:500,height:500,lineWidth:5,arrowColor:y};function pe(t,e,s={}){return new CanvasVisualizer(t,e,s)}class CanvasVisualizer extends Visualizer{constructor(t,e,s){if(s=Object.assign(Object.assign({},ve),s),"string"==typeof t&&null===(t=document.querySelector(t)))throw new Error(`Could not find visuzlier element by query selector: ${t}`);const i=new HtmlCanvasRenderer(s.width,s.height,s.lineWidth,s.arrowColor);t.appendChild(i.domElement),super(i,e,s.puzzle)}}const be={CUBE_3:{LAST_LAYER:{F:[3,4,5,6,7,8],B:[3,4,5,6,7,8],R:[3,4,5,6,7,8],L:[3,4,5,6,7,8],D:[0,1,2,3,4,5,6,7,8]},F2L:{F:[0,1,2],B:[0,1,2],R:[0,1,2],L:[0,1,2],U:[0,1,2,3,4,5,6,7,8]},FIRST_LAYER:{F:[0,1,2,3,4,5],B:[0,1,2,3,4,5],R:[0,1,2,3,4,5],L:[0,1,2,3,4,5],U:[0,1,2,3,4,5,6,7,8]},OLL:{R:[0,1,2,3,4,5,6,7,8],F:[0,1,2,3,4,5,6,7,8],D:[0,1,2,3,4,5,6,7,8],L:[0,1,2,3,4,5,6,7,8],B:[0,1,2,3,4,5,6,7,8]},CORNERS_LAST_LAYER:{U:[1,3,5,7],F:[1,3,4,5,6,7,8],B:[1,3,4,5,6,7,8],R:[1,3,4,5,6,7,8],L:[1,3,4,5,6,7,8],D:[0,1,2,3,4,5,6,7,8]},EDGES_LAST_LAYER:{U:[0,2,6,8],F:[0,2,3,4,5,6,7,8],B:[0,2,3,4,5,6,7,8],R:[0,2,3,4,5,6,7,8],L:[0,2,3,4,5,6,7,8],D:[0,1,2,3,4,5,6,7,8]}},MEGA_3:{OLL:{F:[0,1,2,3,4,5,6,7,8,9,10],R:[0,1,2,3,4,5,6,7,8,9,10],L:[0,1,2,3,4,5,6,7,8,9,10],BR:[0,1,2,3,4,5,6,7,8,9,10],BL:[0,1,2,3,4,5,6,7,8,9,10],d:[0,1,2,3,4,5,6,7,8,9,10],b:[0,1,2,3,4,5,6,7,8,9,10],dl:[0,1,2,3,4,5,6,7,8,9,10],dr:[0,1,2,3,4,5,6,7,8,9,10],bl:[0,1,2,3,4,5,6,7,8,9,10],br:[0,1,2,3,4,5,6,7,8,9,10]}}},ge={Scene,Camera,HtmlSvgRenderer,HtmlCanvasRenderer,PolygonRenderer},we={RubiksCube,RubiksCubeNet,RubiksCubeTopLayer,Megaminx,MegaminxNet,Pyraminx,PyraminxNet,Skewb,SkewbNet,Square1,Square1Net},ye={RubiksCubeSimulator,MegaminxSimulator,PyraminxSimulator,SkewbSimulator,Square1Simualtor},Ee={TurnType:s,parseCubeAlgorithm:l,parseMegaminxAlgorithm:vt,parsePyraminxAlgorithm:ct,parseSkewbAlgorithm:et,parseSquare1Algorithm:Z};return e})()}));
//# sourceMappingURL=puzzleGen.min.js.map