<!DOCTYPE html>
<html>

    <head>
        <meta charset="utf-8" />
        <title>Subsolver</title>
        <style>
            .button {
                border: none;
                color: white;
                padding: 16px 32px;
                text-align: center;
                text-decoration: none;
                display: inline-block;
                font-size: 16px;
                margin: 4px 2px;
                transition-duration: 0.4s;
                cursor: pointer;
            }
    
            .button1 {
                background-color: white;
                color: black;
                border: 2px solid #000000;
            }
    
            .button1:hover {
                background-color: #000000;
                color: white;
            }
            input[type=checkbox] {
                transform: scale(1.3);
            }
            th, td {
            padding: 7px;
            }
        </style>
    </head>
    
    <body>
        <div style="font-family:courier new;font-size:17px">
            <button style="font-family:courier new;font-size:17px" class="button button1"
                onclick="calc()"><strong>Calculate</strong></button> 
            <button style="font-family:courier new;font-size:17px" class="button button1"
                onclick="clearOutput()"><strong>Clear Output</strong></button> 
            <button style="font-family:courier new;font-size:17px" class="button button1" id="optVisButton"
                onclick="optionVisibility()"><strong>Hide Options</strong></button><br>
                
            <strong id="options">
                <br>
                <input id="sortByMCC" type="checkbox"><label for="sortByMCC"> Sort algs by movecount coefficient</label><br>
                <input id="showProgUpdates" type="checkbox" checked><label for="showProgUpdates"> Output progress updates</label><br>
            </strong>
            <br>
            <table valign="top">
                <tr>
                    <th>
                        Input
                    </th>
                    <th>
                        <textarea id="true-input" rows="16" cols="69" spellcheck="false"></textarea>
                    </th>
                </tr>
                <tr>
                    <th>
                        Output
                    </th>
                    <th>
                        <textarea id="output" rows="26" cols="69" spellcheck="false" readonly></textarea>
                    </th>
                </tr>
            </table>
        </div>
    <script>
        "use strict";

        // HTML-SIDE JS
        let activePuzzle;

        function optionVisibility() {
            let options = document.getElementById("options")
            let optVisButton = document.getElementById("optVisButton")
            if (options.hidden) {
                options.hidden = false;
                optVisButton.innerHTML = "<strong>Hide Options</strong>";
            } else {
                options.hidden = true;
                optVisButton.innerHTML = "<strong>Show Options</strong>";
            }
        }

        function status(message, textField=document.getElementById("output")) {
            if (document.getElementById("showProgUpdates").checked) {
                textField.value += (message+"\n");
            }
        }

        function setPuzzle() {
            // Deal with moves input

            let moves = document.getElementById("true-input").value;
            let moveLines = moves.split('\n');

            let pieceList = [];
            let moveDataList = [];

            let cubeOri = [];
            let moveList = [];
            let clockwiseMoveStr = [];

            function parseMove(data) {
                let cycleList = [];
                let openParenSplit = data.split("(");
                for (let i=1; i<openParenSplit.length; i++) {
                    let cycle = [];
                    let cycleStr = openParenSplit[i].split(")")[0];
                    let pieces = cycleStr.split(" ");
                    for (let j=0; j<pieces.length; j++) {
                        let pieceData = pieces[j];
                        if (pieceData != "") {
                            let suffixLoc = pieceData.indexOf('+')==-1?pieceData.indexOf('-'):pieceData.indexOf('+');
                            let piece = suffixLoc==-1 ? pieceData : pieceData.slice(0, suffixLoc);
                            let twist = suffixLoc==-1 ? 0 : parseInt(pieceData.slice(suffixLoc));
                            let pieceIndex = pieceList.indexOf(piece);
                            if (pieceIndex == -1) {
                                pieceList.push(piece);
                                pieceIndex = pieceList.length-1;
                                cubeOri.push(Math.max(1,piece.replace(/[^A-Z]/g, "").length)); // Number of orientations is number of capital letters in piece name, but 1 minimum
                            }
                            cycle.push([pieceIndex, twist]);
                        }
                    }
                    cycleList.push(cycle);
                }
                return cycleList;
            }

            function mod(a, n) { // works with negative a unlike % operator
                return a - (n * Math.floor(a/n));
            }
            
            for (let ln=0; ln<moveLines.length; ln++) {
                let line = moveLines[ln].split("//")[0];
                if (line.includes(":")) {
                    let cycleStr = moveLines[ln].split(":");
                    let moveName = cycleStr[0];
                    clockwiseMoveStr.push(moveName);
                    let cycleList = parseMove(cycleStr[1]);
                    moveDataList.push(cycleList)
                }
            }

            let oriMult = 2**Math.ceil(Math.log2(pieceList.length));

            for (let m=0; m<moveDataList.length; m++) {
                let cycleList = moveDataList[m];
                let move = [];
                for (let i=0; i<pieceList.length; i++) {move.push(i)}
                for (let c=0; c<cycleList.length; c++) {
                    let cycle = cycleList[c];
                    for (let i=0; i<cycle.length-1; i++) {
                        let pieceData = cycle[i];
                        move[cycle[i+1][0]] = cycle[i][0]+oriMult*mod(cycle[i][1],cubeOri[cycle[i][0]]); // there could be bugs here
                    }
                    if (cycle.length==1 || (cycle[0][0] != cycle[cycle.length-1][0])) {
                        move[cycle[0][0]] = cycle[cycle.length-1][0]+oriMult*mod(cycle[cycle.length-1][1],cubeOri[cycle[cycle.length-1][0]]);
                    }
                }
                moveList.push(move);
            }

            // Deal with equivalences
            let splitEquivalences = moves.split('{');
            let solvedState = [];
            for (let i=0; i<pieceList.length; i++) {solvedState[i] = i}
            for (let i=1; i<splitEquivalences.length; i++) {
                let equivSet = splitEquivalences[i].split("}")[0];
                let equivPieces = equivSet.split(" ");
                let equivNum = pieceList.indexOf(equivPieces[0]);
                for (let j=1; j<equivPieces.length; j++) {
                    solvedState[pieceList.indexOf(equivPieces[j])] = equivNum;
                }
            }
            activePuzzle = new Puzzle(cubeOri, moveList, clockwiseMoveStr, solvedState);
            return pieceList;
        }

        function removeBrackets(s) { // Removes (), {}, <>, and []
            return s.replace(/\(|\)|\[|\]|{|}|<|>/g, "");
        }

        function calc() {
            let startTime = Date.now();
            let pieceList = setPuzzle(); // loses efficiency if puzzle has not changed, so update this
            let inputLines = document.getElementById("true-input").value.split("\n");
            let searchDepth = Infinity;
            for (let i=0; i<inputLines.length; i++) {
                let line = inputLines[i]
                let splitLine = line.split(" ");
                for (let j=splitLine.length-1; j>0; j--) {
                    if (splitLine[j] == "") {
                        splitLine.pop();
                    }
                }
                let command = splitLine[0].toLowerCase();
                if (command == "prune") { 
                    activePuzzle.createPrun(parseInt(splitLine[1]));
                    status("Pruning complete.")
                } else if (command == "search") {
                    searchDepth = parseInt(splitLine[1]);
                    status("Set search depth to "+splitLine[1]);
                } else if (command == "solve") {
                    let solve = activePuzzle.solve(activePuzzle.execute(activePuzzle.solved, activePuzzle.moveStrToList(removeBrackets(splitLine.slice(1).join(" ")))), searchDepth);
                    function nextSolution() {
                        let solution = solve.next();
                        if (solution.done == false) {
                            document.getElementById("output").value += activePuzzle.moveListToStr(solution.value)+"\n";
                            requestAnimationFrame(nextSolution);
                        } else {
                            status("Solving completed in "+(Date.now()-startTime)+" milliseconds");
                        }
                    }
                    nextSolution();
                } else if (command == "unique-orient") {
                    for (let i=2; i<splitLine.length; i++) {
                        let pieceIndex = pieceList.indexOf(removeBrackets(splitLine[i]));
                        if (pieceIndex !== -1) {activePuzzle.cubeOri[pieceIndex] = splitLine[1]};
                    }
                } else if (command == "subgroup") {
                    let generators = [];
                    for (let i=1; i<splitLine.length; i++) {
                        generators.push(removeBrackets(splitLine[i]));
                    }
                    activePuzzle.setSubgroup(generators);
                }
            }
        }

        function clearOutput() {
            document.getElementById("output").value = "";
        }

        // END HTML-SIDE JS

        function arraysEqual(arr1,arr2) {
            for (let i=0; i<arr1.length; i++) {
                if (arr1[i] !== arr2[i]) {return false}
            }
            return true
        }

        class Puzzle {
            // executes one move on specified start cube and outputs in result cube.
            mult (start, move, result) {
                for (let p = 0; p < this.pcCount; p++) {
                    let temp = (start[move[p] & this.posMask] + (move[p] & this.oriMask));
                    let tempOri = this.cubeOri[temp & this.posMask];
                    result[p] = temp % (tempOri << this.posBits);
                }
            }
            
            constructor (cubeOri, clockwiseMoves, clockwiseMoveStr, solvedState=null) {
                // initialize cube constants
                this.cubeOri = cubeOri;
                this.pcCount = cubeOri.length; // 20
                this.posBits = Math.ceil(Math.log2(this.pcCount)) // 5; number of bits needed to store piece (without orientation)
                this.posMask = (1 << this.posBits) - 1; // 31
                this.oriMask = ((1 << Math.ceil(Math.log2(Math.max(...cubeOri)))) - 1) << this.posBits; // 3 * 32 = 96
                this.totalBits = Math.ceil(Math.log2(this.oriMask)); // 7
                this.moveStr = [];

                this.nullmove = [];
                for (let i=0; i<this.pcCount; i++) {this.nullmove[i] = i}
                if (solvedState === null) {
                    this.solved = this.nullmove;
                } else {this.solved = solvedState}

                // initialize moves in all directions (ex. clockwise, counter, and double) and inverse mapping
                this.moves = []; // clockwise, counter, and double moves
                this.inverse = []; // mapping of inverse moves
                for (let i=0; i<clockwiseMoves.length; i++) { // initialize the moves array and inverse array
                    this.moves.push(clockwiseMoves[i]); // put the clockwise version of the move in 
                    while (true) {
                        this.moves.push([]);
                        this.mult(this.moves[this.moves.length-2],clockwiseMoves[i],this.moves[this.moves.length-1]); // put the repeated moves in (U2, U')
                        if (arraysEqual(this.moves[this.moves.length-1],this.nullmove)) { // break if repeated move was the solved state
                            this.moves.pop();
                            break;
                        }
                    }
                    let order = this.moves.length-this.inverse.length+1;
                    let currentMove = clockwiseMoveStr.shift();
                    for (let j=1; j<order; j++) { // Loops once for each added move. Adds the string representation of moves to moveStr.
                        if (j <= order/2) {
                            this.moveStr.push(currentMove+(j!=1?j:""));
                        } else {
                            this.moveStr.push(currentMove+((order-j)!=1?(order-j):"")+"'");
                        }
                    }
                    let invCounter = this.moves.length;
                    while (this.inverse.length < this.moves.length) { // initializes the inverses array and moveTypes array for each new element in the moves array
                        invCounter--;
                        this.inverse.push(invCounter);
                    }
                }

                this.nextPossibleMove = [];
                for (let i=0; i<this.moves.length; i++) {this.nextPossibleMove[i] = i+1}
                this.nextPossibleMove[this.moves.length] = 0;

                // initialize valid pairs grid
                this.validPairs = [];
                for (let move1=0; move1<this.moves.length; move1++) { // initialize the valid pairs array
                    this.validPairs[move1] = [];
                    for (let move2=0; move2<this.moves.length; move2++) {
                        let prod1 = [];
                        let prod2 = [];
                        this.mult(this.moves[move1], this.moves[move2], prod1);
                        this.mult(this.moves[move2], this.moves[move1], prod2);
                        // Compares if A B = B A. Two moves of the same type are never valid (like B B2), and two commuting moves of different types are only valid in one way (exactly one of U D2 and D2 U are valid)
                        if (arraysEqual(prod1, prod2)) { 
                            this.validPairs[move1][move2] = (move1 < move2);
                            if (arraysEqual(prod1, this.nullmove)) {
                                this.validPairs[move1][move2] = false;
                            }
                            for (let m=0; m<this.moves.length; m++) {
                                if (arraysEqual(prod1, this.moves[m])) {
                                    this.validPairs[move1][move2] = false;
                                }
                            }
                        } else { 
                            this.validPairs[move1][move2] = true;
                        } 
                    }
                }

                // initialize prunetable (empty upon initialization)
                this.pruneTable = new Map();
                this.pruneDepth = 0;
            }

            // returns next valid move given previous move. For example, U U2 is invalid, but U R is valid.
            nextValid(prevMove, move) {
                while (true) {
                    move = this.nextPossibleMove[move];
                    if (move == this.moves.length || this.validPairs[prevMove][move]) {
                        return move;
                    }
                }
            }
        
            // Convert a puzzle array like [2, 1, 6, 0, 5, 4, 3, 7] into a compact string. The totalBits is the number of bits to allocate per number. Takes place of strConv.
            compressArr(list) {
                let string = "";
                for (let i=0; i<list.length; i++) {
                    string += String.fromCharCode(list[i]);
                }
                return string;
            }
        
            // advances an array of moves to the next valid array. returns the length of the array.
            advance(arr) {
                let moveInd = arr.length-1;
                while (moveInd < arr.length) {
                    if (moveInd) {
                        arr[moveInd] = this.nextValid(arr[moveInd-1],arr[moveInd])
                    } else {
                        arr[0] = this.nextPossibleMove[arr[0]];
                        if (arr[0] == this.moves.length) {
                            arr[0] = this.nextPossibleMove[this.moves.length];
                            let newLength = arr.length+1
                            for (let i=1; i<newLength; i++) {
                                arr[i] = this.nextValid(arr[i-1],this.moves.length)
                            }
                            // console.log("Finished depth "+(newLength-1));
                            return newLength
                        }
                    }
                    if (arr[moveInd] == this.moves.length) {moveInd--} else {moveInd++}
                }
                return arr.length
            }

            // executes sequence on specified starting state
            execute(start, sequence) {
                let tempCube = [];
                for (let j=0; j<sequence.length; j++) {
                    this.mult(start, this.moves[sequence[j]],tempCube)
                    start = tempCube.slice();
                }
                return start
            }

            // convert a sequence of moves, internally represented by a string of numbers, into human-readable text
            moveListToStr(list) {
                let result = "";
                for (let i=0; i<list.length; i++) {
                    result += this.moveStr[list[i]];
                    if (i != list.length-1) {
                        result += " ";
                    }
                }
                return result
            }

            // convert a human-readable algorithm into a string of numbers
            moveStrToList(alg) {
                let result = [];
                let algSplit = alg.split(" ");
                for (let i=0; i<algSplit.length; i++) {
                    if (algSplit[i] != "") {
                        let moveNum = this.moveStr.indexOf(algSplit[i]);
                        if (moveNum != -1) {
                            result.push(moveNum);
                        } else {
                            throw "Invalid input";
                        }
                    }
                }
                return result
            }
            
            // create a prune table
            createPrun(maxDepth) {
                let tempTable = new Map();
                let attempt = [this.nextPossibleMove[this.moves.length]];
                let depth = 1;
                while (depth <= maxDepth) {
                    let cubeStr = this.compressArr(this.execute(this.solved, attempt));
                    if (!(tempTable.has(cubeStr))) {tempTable.set(cubeStr, depth)}
                    depth = this.advance(attempt);
                }
                this.pruneTable = tempTable;
                this.pruneDepth = maxDepth;
            }

            // read all solutions from a given state under the prune table's depth
            *readPrun(state, partialSolve=[], maxDepth=this.pruneDepth) { // maxDepth should be the same as the prune table's maxDepth
                for (let m=0; m<this.moves.length; m++) {
                    if (partialSolve.length == 0 || this.validPairs[partialSolve[partialSolve.length-1]][m]) {
                        let nextState = this.execute(state, [m]);
                        let nextDistance = this.pruneTable.get(this.compressArr(nextState));
                        if (arraysEqual(nextState, this.solved)) {
                            let fullSolve = partialSolve.concat(m);
                            yield * [fullSolve];
                        } else if (nextDistance < maxDepth) { // false if nextDistance is undefined
                            yield * this.readPrun(nextState, partialSolve.concat(m), maxDepth-1);
                        }
                    }
                }
            }

            *solve(state, searchDepth, goal=this.solved) {
                yield * this.readPrun(state);
                let attempt = [0];
                let depth = 1;
                while (depth <= searchDepth) {
                    let nextState = this.execute(state, attempt);
                    if (this.pruneTable.get(this.compressArr(nextState)) == this.pruneDepth) {
                        yield * this.readPrun(nextState, attempt);
                    }
                    depth = this.advance(attempt);
                }                
            }

            setSubgroup(generators) {
                // nextPossibleMove
                let movesInGroup = [];
                for (let i=0; i<generators.length; i++) {
                    let gen = this.moveStr.indexOf(generators[i]);
                    let start = this.nullmove;
                    while(true) {
                        let result = [];
                        this.mult(start, this.moves[gen], result)
                        start = result.slice();
                        // check the move number of the result
                        for (let j=0; j<this.moves.length; j++) {
                            if (arraysEqual(this.moves[j],result)) {
                                movesInGroup.push(j)
                                break
                            }
                        }
                        if (arraysEqual(result, this.nullmove)) {
                            break
                        }
                    }
                }
                movesInGroup.sort((a, b) => a - b);
                this.nextPossibleMove[this.moves.length] = movesInGroup[0];
                this.nextPossibleMove[movesInGroup[movesInGroup.length-1]] = this.moves.length;
                for (let i=0; i<movesInGroup.length-1; i++) {
                    this.nextPossibleMove[movesInGroup[i]] = movesInGroup[i+1];
                }
            }

        }
        
        {
        // Move definitions for non-center 3x3
        let u = [3, 0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 15, 12, 13, 14, 16, 17, 18, 19]; 
        let r = [0, 4, 2, 3, 9, 5, 6, 1, 8, 7, 10, 11, 12, 46, 81, 15, 16, 50, 77, 19]; 
        let f = [0, 1, 37, 3, 34, 40, 6, 7, 36, 9, 10, 11, 12, 13, 47, 80, 49, 78, 18, 19]; 
        let d = [0, 1, 2, 3, 4, 5, 6, 7, 11, 8, 9, 10, 12, 13, 14, 15, 19, 16, 17, 18]; 
        let l = [0, 1, 2, 6, 4, 3, 11, 7, 8, 9, 10, 5, 83, 13, 14, 44, 79, 17, 18, 48]; 
        let b = [39, 1, 2, 3, 4, 5, 32, 42, 8, 9, 38, 11, 45, 82, 14, 15, 16, 17, 51, 76];

        // Move definitions for center 3x3
        let uc = [3, 0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 15, 12, 13, 14, 16, 17, 18, 19, 20, 21, 22];
        let rc = [0, 4, 2, 3, 9, 5, 6, 1, 8, 7, 10, 11, 12, 46, 81, 15, 16, 50, 77, 19, 20, 21, 22];
        let fc = [0, 1, 37, 3, 34, 40, 6, 7, 36, 9, 10, 11, 12, 13, 47, 80, 49, 78, 18, 19, 20, 21, 22];
        let dc = [0, 1, 2, 3, 4, 5, 6, 7, 11, 8, 9, 10, 12, 13, 14, 15, 19, 16, 17, 18, 20, 21, 22]; 
        let lc = [0, 1, 2, 6, 4, 3, 11, 7, 8, 9, 10, 5, 83, 13, 14, 44, 79, 17, 18, 48, 20, 21, 22]; 
        let bc = [39, 1, 2, 3, 4, 5, 32, 42, 8, 9, 38, 11, 45, 82, 14, 15, 16, 17, 51, 76, 20, 21, 22];
        let m = [42, 1, 32, 3, 4, 5, 6, 7, 34, 9, 40, 11, 12, 13, 14, 15, 16, 17, 18, 19, 54, 21, 20];
        let s = [0, 35, 2, 43, 4, 5, 6, 7, 8, 33, 10, 41, 12, 13, 14, 15, 16, 17, 18, 19, 53, 20, 22];
        let e = [0, 1, 2, 3, 37, 38, 39, 36, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 22, 53];
        let uw = [3, 0, 1, 2, 39, 36, 37, 38, 8, 9, 10, 11, 15, 12, 13, 14, 16, 17, 18, 19, 20, 54, 21];
        let rw = [34, 4, 40, 3, 9, 5, 6, 1, 42, 7, 32, 11, 12, 46, 81, 15, 16, 50, 77, 19, 22, 21, 52];
        let fw = [0, 35, 37, 43, 34, 40, 6, 7, 36, 33, 10, 41, 12, 13, 47, 80, 49, 78, 18, 19, 53, 20, 22];
        let dw = [0, 1, 2, 3, 37, 38, 39, 36, 11, 8, 9, 10, 12, 13, 14, 15, 19, 16, 17, 18, 20, 22, 53];
        let lw = [42, 1, 32, 6, 4, 3, 11, 7, 34, 9, 40, 5, 83, 13, 14, 44, 79, 17, 18, 48, 54, 21, 20];
        let bw = [39, 41, 2, 33, 4, 5, 32, 42, 8, 43, 38, 35, 45, 82, 14, 15, 16, 17, 51, 76, 21, 52, 22];

        var ruf3x3 = new Puzzle(
            [1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3], 
            [u, r, f],
            ['U','R','F'],
            [0, 0, 0, 0, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]);

        var coes3x3 = new Puzzle(
            [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2], 
            [uc, rc, uw],
            ['U','R','u'],
            [0, 0, 0, 0, 4, 4, 4, 4, 8, 8, 8, 8, 12, 12, 12, 12, 16, 16, 16, 16, 20, 20, 20]);
        }
        


        
    </script>
</body>

</html>