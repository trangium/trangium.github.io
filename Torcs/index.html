<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>TORCS prototype</title>
    <style>
        .button {
            transition-duration: 0.4s;
            color: white;
            padding: 12px 24px;
            text-align: center;
            display: inline-block;
            font-size: 20px;
            margin: 4px 2px;
            cursor: pointer;
        }

        .solve {
            background-color: white;
            color: black;
            border: 2px solid #0066FF;
        }

        .solve:hover {
            background-color: #0066FF;
            color: white;
        }

        .cross {
            background-color: white;
            color: black;
            border: 2px solid #00CC00;
        }

        .cross:hover {
            background-color: #00CC00;
            color: white;
        }

        .eo {
            background-color: white;
            color: black;
            border: 2px solid #EEB000;
        }

        .eo:hover {
            color: #FFFFFF;
            background-color: #EEB000;
        }

        .eoline {
            background-color: white;
            color: black;
            border: 2px solid #0033AA;
        }

        .eoline:hover {
            background-color: #0033AA;
            color: white;
        }

        .dr {
            background-color: white;
            color: black;
            border: 2px solid #BB0022;
        }

        .dr:hover {
            background-color: #BB0022;
            color: white;
        }

        .block222 {
            background-color: white;
            color: black;
            border: 2px solid #005500;
        }

        .block222:hover {
            background-color: #005500;
            color: white;
        }

        .block223 {
            background-color: white;
            color: black;
            border: 2px solid #009999;
        }

        .block223:hover {
            background-color: #009999;
            color: white;
        }
    </style>
</head>

<body>
    <button class="button solve" onclick="solveInput();">Solve (10 move limit) </button>
    <button class="button cross"
        onclick="solveInput([NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN, 0, 1, 2, 3, NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN], 4, 4);">Cross</button>
    <button class="button eo"
        onclick="solveInput([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN], 3, 4);">EO</button>
    <button class="button eoline"
        onclick="solveInput([0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN], 4, 5);">EO-Line</button>
    <button class="button dr"
        onclick="solveInput([0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 5, 5);">DR</button>
    <button class="button block222"
        onclick="solveInput([NaN, NaN, NaN, NaN, NaN, NaN, 0, NaN, NaN, NaN, 1, 2, NaN, NaN, NaN, NaN, NaN, NaN, NaN, 0], 4, 4);">2x2x2
        block</button>
    <button class="button block223"
        onclick="solveInput([NaN, NaN, NaN, NaN, NaN, 0, 1, NaN, 2, NaN, 3, 4, NaN, NaN, NaN, NaN, 0, NaN, NaN, 1], 5, 5);">2x2x3
        block</button>
    <script>
        var congloMult = function (ac, bc, prod) {
            for (let p = 0; p < pcCount; p++) {
                var temp = (ac[bc[p] & pcPosMask] + (bc[p] & maxOriMask));
                prod[p] = temp < cubeOri[p] << pcPosLen ? temp : temp - (cubeOri[p] << pcPosLen);
            }
        }
        var uCube = [3, 0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 15, 12, 13, 14, 16, 17, 18, 19];
        var rCube = [0, 4, 2, 3, 9, 5, 6, 1, 8, 7, 10, 11, 12, 46, 81, 15, 16, 50, 77, 19];
        var fCube = [0, 1, 37, 3, 34, 40, 6, 7, 36, 9, 10, 11, 12, 13, 47, 80, 49, 78, 18, 19];
        var dCube = [0, 1, 2, 3, 4, 5, 6, 7, 11, 8, 9, 10, 12, 13, 14, 15, 19, 16, 17, 18];
        var lCube = [0, 1, 2, 6, 4, 3, 11, 7, 8, 9, 10, 5, 83, 13, 14, 44, 79, 17, 18, 48];
        var bCube = [39, 1, 2, 3, 4, 5, 32, 42, 8, 9, 38, 11, 45, 82, 14, 15, 16, 17, 51, 76];
        var moves333 = [uCube, rCube, fCube, dCube, lCube, bCube];
        for (let i = 6; i < 18; i++) {
            moves333[i] = [];
            congloMult(moves333[i % 6], moves333[i - 6], moves333[i]);
        }

        var r2Cube = [0, 9, 2, 3, 7, 5, 6, 4, 8, 1, 10, 11, 12, 17, 18, 15, 16, 13, 14, 19];
        var f2Cube = [0, 1, 8, 3, 5, 4, 6, 7, 2, 9, 10, 11, 12, 13, 16, 17, 14, 15, 18, 19];
        var l2Cube = [0, 1, 2, 11, 4, 6, 5, 7, 8, 9, 10, 3, 16, 13, 14, 19, 12, 17, 18, 15];
        var b2Cube = [10, 1, 2, 3, 4, 5, 7, 6, 8, 9, 0, 11, 18, 19, 14, 15, 16, 17, 12, 13];

        var cubeOri = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3];
        var moveFaces = [uCube, rCube, dCube, fCube, lCube, bCube];
        var moveStr = ['U', 'R', 'F', 'D', 'L', 'B'];
        var typeStr = ["", "2", "'"];
        var moveTypes = [3, 3, 3, 3, 3, 3];

        var maxOri, pcCount, pcPosLen, pcPosBin, maxOriMask, pcPosMask, fcCount, distinctMoves, fullMoveStr, moveset, solved, moveTypeSum;
        maxOri = Math.max(...cubeOri); // 3
        pcCount = cubeOri.length; // 20
        pcPosLen = Math.ceil(Math.log2(pcCount)) // 5
        pcPosBin = 1 << pcPosLen; // 32
        maxOriMask = ((1 << Math.ceil(Math.log2(maxOri))) - 1) * pcPosBin; // 3 * 32 = 96
        pcPosMask = pcPosBin - 1; // 31
        fcCount = moveFaces.length; // 6
        distinctMoves = moveTypes.reduce(function (a, b) { return a + b }, 0); // 18
        fullMoveStr = [];
        moveset = [];
        solved = [];
        moveTypeSum = [0];
        for (i = 0; i < pcCount; i++) {
            solved[i] = i;
        }
        for (let i = 0; i < fcCount; i++) { // fill the moveset array, fullMoveStr array, and moveTypeSum array
            if (i) {
                moveTypeSum.push(moveTypeSum[i - 1] + moveTypes[i - 1])
            }
            for (let j = 0; j < moveTypes[i]; j++) {
                fullMoveStr.push(moveStr[i] + (j + 1).toString());
                moveset[moveset.length] = [];
                congloMult((j == 0 ? solved : moveset[moveset.length - 2]), moveFaces[i], moveset[moveset.length - 1]);
            }
        }
        function array_intersect() {
            var i, all, len, ret = [], obj = {};
            for (i = 0; i <= 1; i++) {
                len = arguments[i].length;
                for (var j = 0; j < len; j++) {
                    var elem = arguments[i][j];
                    if (obj[elem] === i - 1) {
                        if (i === 1) {
                            ret.push(elem);
                            obj[elem] = 0;
                        } else {
                            obj[elem] = i;
                        }
                    } else if (i === 0) {
                        obj[elem] = 0;
                    }
                }
            }
            return ret;
        }
        function neighbors(state) {
            let neigh = [];
            for (let i = 0; i < 6; i++) {
                neigh[i] = [];
                congloMult(state, moveset[i], neigh[i]);
            }
            return neigh;
        }
        function mask(state) {
            let m = "";
            for (let i = 0; i < pcCount; i++) {
                let u = state[i]
                if (u == u) { m += u };
                m += " ";
            }
            return m
        }
        function reachable(state, n) {
            var reached = new Map([[mask(state), [state, ""]]])
            for (let i = n; i > 0; i--) {
                let statemasks = Array.from(reached.keys());
                for (let k = 0, klen = statemasks.length; k < klen; k++) {
                    let statemask = statemasks[k];
                    let stateprop = reached.get(statemask);
                    let neighborlist = neighbors(stateprop[0]);
                    for (let j = 0, jlen = neighborlist.length; j < jlen; j++) {
                        let nmask = mask(neighborlist[j]);
                        if (!(reached.has(nmask))) {
                            reached.set(nmask, [neighborlist[j], reached.get(statemask)[1] + fullMoveStr[j] + " "]);
                        }
                    }
                }
            }
            return reached;
        }
        function invert(sequence) {
            let m = "";
            let brokenSeq = sequence.split(" ");
            for (let i = brokenSeq.length; i; i--) {
                let mfrag = brokenSeq[i - 1];
                if (mfrag.length) {
                    m += mfrag[0];
                    m += moveTypes[moveStr.indexOf(mfrag[0])] - (mfrag.slice(1)) + 1
                    m += " ";
                }
            }
            return m;
        }
        function convert(sequence) {
            let m = "";
            let brokenSeq = sequence.split(" ");
            for (let i = 0; i < brokenSeq.length; i++) {
                let mfrag = brokenSeq[i];
                if (mfrag.length) {
                    m += mfrag[0];
                    m += typeStr[mfrag.slice(1) - 1];
                    m += " ";
                }
            }
            return m;
        }
        function doMoves(sequence, state = solved) {
            var movelist = [];
            let brokenSeq = sequence.split(" ");
            for (let i = 0; i < brokenSeq.length; i++) {
                if (brokenSeq[i].length) {
                    movelist[i] = moveTypeSum[moveStr.indexOf(brokenSeq[i][0])] + typeStr.indexOf(brokenSeq[i].slice(1))
                }
            }
            var cube = state;
            var temp = [];
            for (let moveind = 0; moveind < movelist.length; moveind++) {
                congloMult(cube, moveset[movelist[moveind]], temp);
                cube = temp.slice();
            }
            return cube;
        }
        function solve(state, fn, bn, goal = solved) { // returns one solution of length <= fn+bn.
            let forward = reachable(state, fn);
            let backward = reachable(goal, bn);
            for (let fdreachable of forward.keys()) {
                if (backward.has(fdreachable)) {
                    return convert(forward.get(fdreachable)[1] + invert(backward.get(fdreachable)[1]));
                }
            }
        }
        function solveInput(state = solved, fn = 5, bn = 5) {
            alert(solve(doMoves(prompt("Scramble:"), state), fn, bn, state));
        }
    </script>
</body>

</html>