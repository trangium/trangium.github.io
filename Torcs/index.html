<!DOCTYPE html>
<html>

    <head>
        <meta charset="utf-8" />
        <title>Subsolver</title>
        <style>
            .button {
                border: none;
                color: white;
                padding: 16px 32px;
                text-align: center;
                text-decoration: none;
                display: inline-block;
                font-size: 16px;
                margin: 4px 2px;
                transition-duration: 0.4s;
                cursor: pointer;
            }
    
            .button1 {
                background-color: white;
                color: black;
                border: 2px solid #000000;
            }
    
            .button1:hover {
                background-color: #000000;
                color: white;
            }
            input[type=checkbox] {
                transform: scale(1.3);
            }
        </style>
    </head>
    
    <body>
        <div style="font-family:courier new;font-size:17px">
            <button style="font-family:courier new;font-size:17px" class="button button1"
                onclick="calc()"><strong>Calculate</strong></button> 
            <button style="font-family:courier new;font-size:17px" class="button button1" id="optVisButton"
                onclick="optionVisibility()"><strong>Show Options</strong></button><br>
            <strong id="options" hidden>
                <br>
                <input id="sortByMCC" type="checkbox"><label for="sortByMCC"> Sort algs by movecount coefficient</label><br>
            </strong>
            <br>
            <table>
                <tr>
                    <th>Puzzle Definition File</th>
                    <th>Output</th>
                </tr>
                <tr>
                    <th><textarea id="input" rows="28" cols="69"></textarea></th>
                    <th><textarea id="output" rows="28" cols="69" readonly style="text-align: right"></textarea> </th>
                </tr>
            </table>
        </div>
    <script>
        "use strict";

        // HTML-SIDE JS
        function optionVisibility() {
            let options = document.getElementById("options")
            let optVisButton = document.getElementById("optVisButton")
            if (options.hidden) {
                options.hidden = false;
                optVisButton.innerHTML = "<strong>Hide Options</strong>";
            } else {
                options.hidden = true;
                optVisButton.innerHTML = "<strong>Show Options</strong>";
            }
        }
        function calc() {
            let input = document.getElementById("input").value.split('\n');
            for (let i=0; i<input.length; i++) {
                let inputLn = input[i];
                console.log(inputLn);
            }
        }
        // END HTML-SIDE JS

        function arraysEqual(arr1,arr2) {
            for (let i=0; i<arr1.length; i++) {
                if (arr1[i] !== arr2[i]) {return false}
            }
            return true
        }

        class Puzzle {
            // executes one move on specified start cube and outputs in result cube.
            mult (start, move, result) {
                for (let p = 0; p < this.pcCount; p++) {
                    let temp = (start[move[p] & this.posMask] + (move[p] & this.oriMask));
                    let tempOri = this.cubeOri[temp & this.posMask];
                    result[p] = temp < tempOri << this.posBits ? temp : temp - (tempOri << this.posBits);
                }
            }
            
            constructor (cubeOri, clockwiseMoves, moveStr, solvedState=null) {
                // initialize cube constants
                this.cubeOri = cubeOri;
                this.pcCount = cubeOri.length; // 20
                this.posBits = Math.ceil(Math.log2(this.pcCount)) // 5; number of bits needed to store piece (without orientation)
                this.posMask = (1 << this.posBits) - 1; // 31
                this.oriMask = ((1 << Math.ceil(Math.log2(Math.max(...cubeOri)))) - 1) << this.posBits; // 3 * 32 = 96
                this.totalBits = Math.ceil(Math.log2(this.oriMask)); // 7
                this.moveStr = moveStr;

                this.nullmove = [];
                for (let i=0; i<this.pcCount; i++) {this.nullmove[i] = i}
                if (solvedState === null) {
                    this.solved = this.nullmove;
                } else {this.solved = solvedState}

                // initialize moves in all directions (ex. clockwise, counter, and double) and inverse mapping
                this.moves = []; // clockwise, counter, and double moves
                this.inverse = []; // mapping of inverse moves
                for (let i=0; i<clockwiseMoves.length; i++) { // initialize the moves array and inverse array
                    this.moves.push(clockwiseMoves[i]); // put the clockwise version of the move in 
                    while (true) {
                        this.moves.push([]);
                        this.mult(this.moves[this.moves.length-2],clockwiseMoves[i],this.moves[this.moves.length-1]); // put the repeated moves in (U2, U')
                        if (arraysEqual(this.moves[this.moves.length-1],this.nullmove)) { // break if repeated move was the solved state
                            this.moves.pop();
                            break;
                        }
                    }
                    let invCounter = this.moves.length;
                    while (this.inverse.length < this.moves.length) { // initializes the inverses array and moveTypes array for each new element in the moves array
                        invCounter--;
                        this.inverse.push(invCounter);
                    }
                }

                // initialize valid pairs grid
                this.validPairs = [];
                for (let move1=0; move1<this.moves.length; move1++) { // initialize the valid pairs array
                    this.validPairs[move1] = [];
                    for (let move2=0; move2<this.moves.length; move2++) {
                        let prod1 = [];
                        let prod2 = [];
                        this.mult(this.moves[move1], this.moves[move2], prod1);
                        this.mult(this.moves[move2], this.moves[move1], prod2);
                        // Compares if A B = B A. Two moves of the same type are never valid (like B B2), and two commuting moves of different types are only valid in one way (exactly one of U D2 and D2 U are valid)
                        if (arraysEqual(prod1, prod2)) { 
                            this.validPairs[move1][move2] = (move1 < move2);
                            if (arraysEqual(prod1, this.nullmove)) {
                                this.validPairs[move1][move2] = false;
                            }
                            for (let m=0; m<this.moves.length; m++) {
                                if (arraysEqual(prod1, this.moves[m])) {
                                    this.validPairs[move1][move2] = false;
                                }
                            }
                        } else { 
                            this.validPairs[move1][move2] = true;
                        } 
                    }
                }

                // initialize prunetable (empty upon initialization)
                this.pruneTable = new Map();
                this.pruneDepth = 0;
            }

            // returns next valid move given previous move. For example, U U2 is invalid, but U R is valid.
            nextValid(prevMove, move) {
                while (move < this.pcCount) {
                    move += 1;
                    if (this.validPairs[prevMove][move]) {
                        return move;
                    }
                }
                return -1
            }
        
            // Convert a puzzle array like [2, 1, 6, 0, 5, 4, 3, 7] into a compact string. The totalBits is the number of bits to allocate per number. Takes place of strConv.
            compressArr(list) {
                if (this.totalBits < 7) {
                    let string = "";
                    let charVal = list[0];
                    let remainingBits = 7-this.totalBits;
                    for (let i=1; i<list.length; i++) {
                        if (remainingBits >= this.totalBits) {
                            charVal *= 2**this.totalBits;
                            charVal += list[i];
                            remainingBits -= this.totalBits
                        } else {
                            charVal *= 2**remainingBits;
                            let value2 = list[i]&&(2**(this.totalBits-remainingBits)-1)
                            string += String.fromCharCode(charVal+(list[i]>>(this.totalBits-remainingBits)));
                            charVal = value2;
                            remainingBits += 7-this.totalBits;
                        }
                    }
                    return string
                } else if (this.totalBits > 7) {
                    let string = "";
                    let i = 0;
                    let remainingBits = this.totalBits;
                    let currentNum = list[0];
                    while (true) {
                        if (remainingBits >= 7) {
                            remainingBits -= 7
                            let first7bits = currentNum >> (remainingBits)
                            string += String.fromCharCode(first7bits);
                            currentNum -= (first7bits << (remainingBits));
                        } else {
                            i++
                            remainingBits = this.totalBits-(7-remainingBits)
                            let firstnbits = list[i] >> (remainingBits)
                            string += String.fromCharCode(currentNum*2**(this.totalBits-remainingBits)+firstnbits);
                            if (i >= list.length) {return string}
                            currentNum = list[i] - (firstnbits << remainingBits); 
                        }
                    }
                } else {
                    let string = "";
                    for (let i=0; i<list.length; i++) {
                        string += String.fromCharCode(list[i])
                    }
                    return string;
                }
            }
        
            // advances an array of moves to the next valid array. returns the length of the array.
            advance(arr) {
                let moveInd = arr.length-1;
                while (moveInd < arr.length) {
                    if (moveInd) {
                        arr[moveInd] = this.nextValid(arr[moveInd-1],arr[moveInd])
                    } else {
                        arr[0] = arr[0]+1;
                        if (arr[0] == this.moves.length) {
                            arr[0] = 0;
                            let newLength = arr.length+1
                            for (let i=1; i<newLength; i++) {
                                arr[i] = this.nextValid(arr[i-1],-1)
                            }
                            // console.log("Finished depth "+(newLength-1));
                            return newLength
                        }
                    }
                    if (arr[moveInd] == -1) {moveInd--} else {moveInd++}
                }
                return arr.length
            }

            // executes sequence on specified starting state
            execute(start, sequence) {
                let tempCube = [];
                for (let j=0; j<sequence.length; j++) {
                    this.mult(start, this.moves[sequence[j]],tempCube)
                    start = tempCube.slice();
                }
                return start
            }

            // convert a sequence of moves, internally represented by a string of numbers, into human-readable text
            moveListToStr(list) {
                let result = "";
                for (let i=0; i<list.length; i++) {
                    result += this.moveStr[list[i]];
                    if (i != list.length-1) {
                        result += " ";
                    }
                }
                return result
            }

            // convert a human-readable algorithm into a string of numbers
            moveStrToList(alg) {
                let result = [];
                let algSplit = alg.split(" ");
                for (let i=0; i<algSplit.length; i++) {
                    if (algSplit[i] != "") {
                        let moveNum = this.moveStr.indexOf(algSplit[i]);
                        if (moveNum != -1) {
                            result.push(moveNum);
                        } else {
                            throw "Invalid input";
                        }
                    }
                }
                return result
            }
            
            // create a prune table
            createPrun(maxDepth) {
                let tempTable = new Map();
                let attempt = [0];
                let depth = 1;
                while (depth <= maxDepth) {
                    let cubeStr = this.compressArr(this.execute(this.solved, attempt));
                    if (!(tempTable.has(cubeStr))) {tempTable.set(cubeStr, depth)}
                    depth = this.advance(attempt);
                }
                this.pruneTable = tempTable;
                this.pruneDepth = maxDepth;
            }

            // read all solutions from a given state under the prune table's depth
            *readPrun(state, partialSolve=[], maxDepth=this.pruneDepth) { // maxDepth should be the same as the prune table's maxDepth
                for (let m=0; m<this.moves.length; m++) {
                    if (partialSolve.length == 0 || this.validPairs[partialSolve[partialSolve.length-1]][m]) {
                        let nextState = this.execute(state, [m]);
                        let nextDistance = this.pruneTable.get(this.compressArr(nextState));
                        if (arraysEqual(nextState, this.solved)) {
                            let fullSolve = partialSolve.concat(m);
                            yield * [fullSolve];
                        } else if (nextDistance < maxDepth) { // false if nextDistance is undefined
                            yield * this.readPrun(nextState, partialSolve.concat(m), maxDepth-1);
                        }
                    }
                }
            }

            *solve(state, searchDepth, goal=this.solved) {
                yield * this.readPrun(state);
                let attempt = [0];
                let depth = 1;
                while (depth <= searchDepth) {
                    let nextState = this.execute(state, attempt);
                    if (this.pruneTable.get(this.compressArr(nextState)) == this.pruneDepth) {
                        yield * this.readPrun(nextState, attempt);
                    }
                    depth = this.advance(attempt);
                }                
            }

        }
        
        {
        // Move definitions for non-center 3x3
        let u = [3, 0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 15, 12, 13, 14, 16, 17, 18, 19]; 
        let r = [0, 4, 2, 3, 9, 5, 6, 1, 8, 7, 10, 11, 12, 46, 81, 15, 16, 50, 77, 19]; 
        let f = [0, 1, 37, 3, 34, 40, 6, 7, 36, 9, 10, 11, 12, 13, 47, 80, 49, 78, 18, 19]; 
        let d = [0, 1, 2, 3, 4, 5, 6, 7, 11, 8, 9, 10, 12, 13, 14, 15, 19, 16, 17, 18]; 
        let l = [0, 1, 2, 6, 4, 3, 11, 7, 8, 9, 10, 5, 83, 13, 14, 44, 79, 17, 18, 48]; 
        let b = [39, 1, 2, 3, 4, 5, 32, 42, 8, 9, 38, 11, 45, 82, 14, 15, 16, 17, 51, 76];

        // Move definitions for center 3x3
        let uc = [3, 0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 15, 12, 13, 14, 16, 17, 18, 19, 20, 21, 22];
        let rc = [0, 4, 2, 3, 9, 5, 6, 1, 8, 7, 10, 11, 12, 46, 81, 15, 16, 50, 77, 19, 20, 21, 22];
        let fc = [0, 1, 37, 3, 34, 40, 6, 7, 36, 9, 10, 11, 12, 13, 47, 80, 49, 78, 18, 19, 20, 21, 22];
        let dc = [0, 1, 2, 3, 4, 5, 6, 7, 11, 8, 9, 10, 12, 13, 14, 15, 19, 16, 17, 18, 20, 21, 22]; 
        let lc = [0, 1, 2, 6, 4, 3, 11, 7, 8, 9, 10, 5, 83, 13, 14, 44, 79, 17, 18, 48, 20, 21, 22]; 
        let bc = [39, 1, 2, 3, 4, 5, 32, 42, 8, 9, 38, 11, 45, 82, 14, 15, 16, 17, 51, 76, 20, 21, 22];
        let m = [42, 1, 32, 3, 4, 5, 6, 7, 34, 9, 40, 11, 12, 13, 14, 15, 16, 17, 18, 19, 54, 21, 20];
        let s = [0, 35, 2, 43, 4, 5, 6, 7, 8, 33, 10, 41, 12, 13, 14, 15, 16, 17, 18, 19, 53, 20, 22];
        let e = [0, 1, 2, 3, 37, 38, 39, 36, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 22, 53];
        let uw = [3, 0, 1, 2, 39, 36, 37, 38, 8, 9, 10, 11, 15, 12, 13, 14, 16, 17, 18, 19, 20, 54, 21];
        let rw = [34, 4, 40, 3, 9, 5, 6, 1, 42, 7, 32, 11, 12, 46, 81, 15, 16, 50, 77, 19, 22, 21, 52];
        let fw = [0, 35, 37, 43, 34, 40, 6, 7, 36, 33, 10, 41, 12, 13, 47, 80, 49, 78, 18, 19, 53, 20, 22];
        let dw = [0, 1, 2, 3, 37, 38, 39, 36, 11, 8, 9, 10, 12, 13, 14, 15, 19, 16, 17, 18, 20, 22, 53];
        let lw = [42, 1, 32, 6, 4, 3, 11, 7, 34, 9, 40, 5, 83, 13, 14, 44, 79, 17, 18, 48, 54, 21, 20];
        let bw = [39, 41, 2, 33, 4, 5, 32, 42, 8, 43, 38, 35, 45, 82, 14, 15, 16, 17, 51, 76, 21, 52, 22];

        var norm3x3 = new Puzzle(
            [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3], 
            [u, r, f, d, l, b],
            ['U','U2',"U'",'R','R2',"R'",'F','F2',"F'",'D','D2',"D'",'L','L2',"L'",'B','B2',"B'"]);

        var coes3x3 = new Puzzle(
            [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2], 
            [uc, rc, uw],
            ['U','U2',"U'",'R','R2',"R'",'u','u2',"u'"],
            [0, 0, 0, 0, 4, 4, 4, 4, 8, 8, 8, 8, 12, 12, 12, 12, 16, 16, 16, 16, 20, 20, 20]);
        }
        
        // let a = Date.now()
        // norm3x3.createPrun(5);
        // console.log(Date.now()-a);

        // let solveTest = norm3x3.solve(norm3x3.execute(norm3x3.solved, norm3x3.moveStrToList("R U R' F' R U R' U' R' F R2 U' R'")), 6);
        // norm3x3.moveListToStr(solveTest.next().value)

        let b = Date.now()
        coes3x3.createPrun(5);
        console.log(Date.now()-b);

        let solve2 = coes3x3.solve(coes3x3.execute(coes3x3.solved, coes3x3.moveStrToList("R' U R2 U R' u2 R U' R2 U' R u2")), 7);
        // coes3x3.moveListToStr(solve2.next().value)

        
    </script>
</body>

</html>