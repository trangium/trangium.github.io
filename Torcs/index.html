<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>TORCS prototype</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        canvas {
            background: #eee;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>

<body>

    <canvas id="myCanvas" width="480" height="320"></canvas>

    <script>
        var canvas = document.getElementById("myCanvas");
        var ctx = canvas.getContext("2d");
        ctx.font = "20px Century Gothic";

        var types = 2;
        var typecount = [12, 8];
        var typeori = [2, 3];
        var faces = 6; // rotatable faces

        var typebin = [16, 8]; // typecount, each element is the next power of 2
        var typebinmask = [15, 7]; // typebin, each element minus 1
        var typemax = [32, 24]; // typeori * typebin
        var typemaxmask = [31, 23]; // typemax, each element minus 1

        var uEdge = [3, 0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11]; // initialize where edges go after each clockwise move
        var rEdge = [0, 4, 2, 3, 9, 5, 6, 1, 8, 7, 10, 11];
        var fEdge = [0, 1, 21, 3, 18, 24, 6, 7, 20, 9, 10, 11];
        var dEdge = [0, 1, 2, 3, 4, 5, 6, 7, 11, 8, 9, 10];
        var lEdge = [0, 1, 2, 6, 4, 3, 11, 7, 8, 9, 10, 5];
        var bEdge = [23, 1, 2, 3, 4, 5, 16, 26, 8, 9, 22, 11];
        var edgeMove = [uEdge, rEdge, fEdge, dEdge, lEdge, bEdge];

        var uCorn = [3, 0, 1, 2, 4, 5, 6, 7]; // initialize where corners go after each clockwise move
        var rCorn = [0, 10, 21, 3, 4, 14, 17, 7];
        var fCorn = [0, 1, 11, 20, 13, 18, 6, 7];
        var dCorn = [0, 1, 2, 3, 7, 4, 5, 6];
        var lCorn = [23, 1, 2, 8, 19, 5, 6, 12];
        var bCorn = [9, 22, 2, 3, 4, 5, 15, 16];
        var cornMove = [uCorn, rCorn, fCorn, dCorn, lCorn, bCorn];

        var cubeMult = function(ae, ac, be, bc, pe, pc) {
            for (let ed = 0; ed < typecount[0]; ed++) { 
                pe[ed] = (ae[be[ed] & typebinmask[0]] + (be[ed] & typebin[0])) & typemaxmask[0];
            }
            for (let corn = 0; corn < typecount[1]; corn++) { // compute corner product
                var temp = (ac[bc[corn] & typebinmask[1]] + (bc[corn] & typemax[1]));
                pc[corn] = temp<typemax[1] ? temp : temp-typemax[1]; 
            }
        } // potential for currying (It might be premature optimization but it's also a useful thing for me to learn)

        for (let i=0; i<12; i++) { // initialize compositions of single moves (double and counterclockwise moves)
            edgeMove[i+faces] = [];
            cornMove[i+faces] = [];
            cubeMult(edgeMove[i], cornMove[i], edgeMove[i%faces], cornMove[i%faces], edgeMove[i+faces], cornMove[i+faces]);
        }
        
        function doMoves(movelist) {
            let cubeEdge = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
            let cubeCorn = [0, 1, 2, 3, 4, 5, 6, 7];
            let edgeTemp = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
            let cornTemp = [0, 1, 2, 3, 4, 5, 6, 7];
            for (let i=0; i<movelist.length; i++) {
                cubeMult(cubeEdge, cubeCorn, edgeMove[movelist[i]], cornMove[movelist[i]], edgeTemp, cornTemp);
                cubeEdge = edgeTemp.slice();
                cubeCorn = cornTemp.slice();
                console.log(cubeCorn);
            }
            return [cubeEdge, cubeCorn];
        }

        function* neighbors(edState, cornState) {
            for (let i=0; i<edgeMove.length; i++) {
                let prodE = [];
                let prodC = [];
                cubeMult(edState, cornState, edgeMove[i], cornMove[i], prodE, prodC);
                yield ([prodE, prodC]);
            }
        }

        var prod = doMoves([6, 9, 7, 10, 8, 11]); // return a checkerboard

        for (let i of neighbors([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [0, 1, 2, 3, 4, 5, 6, 7])) {
            console.log(i)
        }
        
    </script>

</body>

</html>