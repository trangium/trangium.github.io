<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>TORCS prototype</title>
    <style>
        .button {
            transition-duration: 0.4s;
            color: white;
            padding: 12px 24px;
            text-align: center;
            display: inline-block;
            font-size: 20px;
            margin: 4px 2px;
            cursor: pointer;
            font: arial;
        }

        .solve {
            background-color: white;
            color: black;
            border: 2px solid #0066FF;
        }

        .solve:hover {
            background-color: #0066FF;
            color: white;
        }

        .cross {
            background-color: white;
            color: black;
            border: 2px solid #00CC00;
        }

        .cross:hover {
            background-color: #00CC00;
            color: white;
        }

        .eo {
            background-color: white;
            color: black;
            border: 2px solid #EED000;
        }

        .eo:hover {
            background-color: #EED000;
        }

        .eoline {
            background-color: white;
            color: black;
            border: 2px solid #0033AA;
        }

        .eoline:hover {
            background-color: #0033AA;
            color: white;
        }

        .dr {
            background-color: white;
            color: black;
            border: 2px solid #BB0022;
        }

        .dr:hover {
            background-color: #BB0022;
            color: white;
        }

        .block222 {
            background-color: white;
            color: black;
            border: 2px solid #005500;
        }

        .block222:hover {
            background-color: #005500;
            color: white;
        }

        .block223 {
            background-color: white;
            color: black;
            border: 2px solid #009999;
        }

        .block223:hover {
            background-color: #009999;
            color: white;
        }
    </style>
</head>

<body>
    <button class="button solve" onclick="solveInput();">Solve (10 move limit) </button>
    <button class="button cross"
        onclick="solveInput([NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN, 0, 1, 2, 3, NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN], 4, 4);">Cross</button>
    <button class="button eo"
        onclick="solveInput([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN], 3, 4);">EO</button>
    <button class="button eoline"
        onclick="solveInput([0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN], 4, 5);">EO-Line</button>
    <button class="button dr"
        onclick="solveInput([0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 5, 5);">DR</button>
    <button class="button block222"
        onclick="solveInput([NaN, NaN, NaN, NaN, NaN, NaN, 0, NaN, NaN, NaN, 1, 2, NaN, NaN, NaN, NaN, NaN, NaN, NaN, 0], 4, 4);">2x2x2
        block</button>
    <button class="button block223"
        onclick="solveInput([NaN, NaN, NaN, NaN, NaN, 0, 1, NaN, 2, NaN, 3, 4, NaN, NaN, NaN, NaN, 0, NaN, NaN, 1], 5, 5);">2x2x3
        block</button>
    <script>
        var cubeOri = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3];
        var maxOri = Math.max(...cubeOri); // 3
        var pcCount = cubeOri.length; // 20
        var pcPosLen = Math.ceil(Math.log2(pcCount)) // 5
        var pcPosBin = 1 << pcPosLen; // 32
        var pcPosMask = pcPosBin - 1; // 31
        var maxOriMask = ((1 << Math.ceil(Math.log2(maxOri))) - 1) * pcPosBin; // 3 * 32 = 96

        var uCube = [3, 0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 15, 12, 13, 14, 16, 17, 18, 19];
        var rCube = [0, 4, 2, 3, 9, 5, 6, 1, 8, 7, 10, 11, 12, 46, 81, 15, 16, 50, 77, 19];
        var fCube = [0, 1, 37, 3, 34, 40, 6, 7, 36, 9, 10, 11, 12, 13, 47, 80, 49, 78, 18, 19];
        var dCube = [0, 1, 2, 3, 4, 5, 6, 7, 11, 8, 9, 10, 12, 13, 14, 15, 19, 16, 17, 18];
        var lCube = [0, 1, 2, 6, 4, 3, 11, 7, 8, 9, 10, 5, 83, 13, 14, 44, 79, 17, 18, 48];
        var bCube = [39, 1, 2, 3, 4, 5, 32, 42, 8, 9, 38, 11, 45, 82, 14, 15, 16, 17, 51, 76];
        var moves = [uCube, rCube, fCube, dCube, lCube, bCube];

        var moveStr = ['U', 'R', 'F', 'D', 'L', 'B'];
        var typeStr = ["", "2", "'"];

        var fcCount = moves.length; // 6
        var moveTypes = typeStr.length; // Multiplicity of the move: the number of sides minus 1
        var distinctMoves = fcCount * moveTypes // 18
        var fullMoveStr = [];
        for (let i = 0; i < moveTypes; i++) {
            for (let j = 0; j < fcCount; j++) {
                fullMoveStr.push(moveStr[j] + (i + 1).toString());
            }
        }
        var solved = [];
        for (i = 0; i < pcCount; i++) {
            solved[i] = i;
        }
        var congloMult = function (ac, bc, prod) {
            for (let p = 0; p < pcCount; p++) {
                var temp = (ac[bc[p] & pcPosMask] + (bc[p] & maxOriMask));
                prod[p] = temp < cubeOri[p] << pcPosLen ? temp : temp - (cubeOri[p] << pcPosLen);
            }
        }
        for (let i = 0; i < distinctMoves - fcCount; i++) {
            moves[i + fcCount] = [];
            congloMult(moves[i], moves[i % fcCount], moves[i + fcCount]);
        }
        function neighbors(state) {
            let neigh = [];
            for (let i = 0; i < distinctMoves; i++) {
                neigh[i] = [];
                congloMult(state, moves[i], neigh[i]);
            }
            return neigh;
        }
        function mask(state) {
            let m = "";
            for (let i = 0; i < pcCount; i++) {
                let u = state[i]
                if (u == u) { m += u };
                m += " ";
            }
            return m
        }
        function reachable(state, n) {
            var reached = new Map([[mask(state), [state, ""]]])
            for (let i = n; i > 0; i--) {
                let statemasks = Array.from(reached.keys());
                for (let k = 0, klen = statemasks.length; k < klen; k++) {
                    let statemask = statemasks[k];
                    let stateprop = reached.get(statemask);
                    let neighborlist = neighbors(stateprop[0]);
                    for (let j = 0, jlen = neighborlist.length; j < jlen; j++) {
                        let nmask = mask(neighborlist[j]);
                        if (!(reached.has(nmask))) {
                            reached.set(nmask, [neighborlist[j], reached.get(statemask)[1] + fullMoveStr[j] + " "]);
                        }
                    }
                }
            }
            return reached;
        }
        function invert(sequence) {
            let m = "";
            let brokenSeq = sequence.split(" ");
            for (let i = brokenSeq.length; i; i--) {
                let mfrag = brokenSeq[i - 1];
                if (mfrag.length) {
                    m += mfrag[0];
                    m += moveTypes - (mfrag.slice(1)) + 1
                    m += " ";
                }
            }
            return m;
        }
        function convert(sequence) {
            let m = "";
            let brokenSeq = sequence.split(" ");
            for (let i = 0; i < brokenSeq.length; i++) {
                let mfrag = brokenSeq[i];
                if (mfrag.length) {
                    m += mfrag[0];
                    m += typeStr[mfrag.slice(1) - 1];
                    m += " ";
                }
            }
            return m;
        }
        function doMoves(sequence, state = solved) {
            var movelist = [];
            let brokenSeq = sequence.split(" ");
            for (let i = 0; i < brokenSeq.length; i++) {
                if (brokenSeq[i].length) {
                    movelist[i] = moveStr.indexOf(brokenSeq[i][0]) + fcCount * typeStr.indexOf(brokenSeq[i].slice(1))
                }
            }
            var cube = state;
            var temp = [];
            for (let moveind = 0; moveind < movelist.length; moveind++) {
                congloMult(cube, moves[movelist[moveind]], temp);
                cube = temp.slice();
            }
            return cube;
        }
        function solve(state, fn, bn, goal = solved) { // returns one solution of length <= fn+bn.
            let forward = reachable(state, fn);
            let backward = reachable(goal, bn);
            for (let fdreachable of forward.keys()) {
                if (backward.has(fdreachable)) {
                    return convert(forward.get(fdreachable)[1] + invert(backward.get(fdreachable)[1]));
                }
            }
        }
        function solveInput(state = solved, fn = 5, bn = 5) {
            const scr = prompt("Scramble:");
            alert(solve(doMoves(scr, state), fn, bn, state));
        }

    </script>
</body>

</html>